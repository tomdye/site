{"value":{"body":"[{\"id\":4461,\"date\":\"2012-06-25T14:29:02\",\"date_gmt\":\"2012-06-25T21:29:02\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=4461\"},\"modified\":\"2019-12-11T05:46:39\",\"modified_gmt\":\"2019-12-11T13:46:39\",\"slug\":\"amd-the-definitive-source\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/amd-the-definitive-source/\",\"title\":{\"rendered\":\"AMD: The Definitive Source\"},\"content\":{\"rendered\":\"<h2>So what is AMD?</h2>\\n<p>As web applications continue to grow more advanced and more heavily rely on JavaScript, there has been a growing movement towards using modules to organize code and dependencies. Modules give us a way to make clearly distinguished components and interfaces that can easily be loaded and connected to dependencies. The AMD module system gives us the perfect path for using JavaScript modules to build web applications, with a simple format, asynchronous loading, and broad adoption.</p>\\n<p>The Asynchronous Module Definition (AMD) format is an API for defining reusable modules that can be used across different frameworks. AMD was developed to provide a way to define modules such that they could be loaded asynchronously using  the native browser script element-based mechanism. The AMD API grew out of <a href=\\\"http://thread.gmane.org/gmane.comp.web.dojo.devel/10914/focus=11303\\\">discussions in 2009 in the Dojo community</a> which then moved to discussions with CommonJS on how to better adapt the CommonJS module format (used by NodeJS) for the browser. It has since grown into its own standard with its own community. AMD has taken off in popularity, with numerous module loaders and widespread usage. At SitePen we have worked extensively with AMD in Dojo, adding support and now actively building applications with this format.</p>\\n<p><!--more--></p>\\n<div style=\\\"float: right; width: 250px; background-color: #f6f6f2; border: 1px solid #bbb; font-size: 80%; padding: 1em; margin: 1.5em;\\\">\\n<h3 style=\\\"margin-top: 0.2em; font-size: 1.2em;\\\">Glossary</h3>\\n<ul style=\\\"padding-left: 25px;\\\">\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Module</strong> &#8211; An encapsulated JavaScript file that follows a module format, indicating dependencies and providing exports.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Module ID</strong> &#8211; This is the unique string that identifies a module. There are relative module ids that resolve to absolute module ids relative to the current module&#8217;s id.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Module Path</strong> &#8211; This is the URL that is used to retrieve a module. A module id is mapped to the module path based on the loader&#8217;s configuration rules (by default, modules are assumed to be relative to the base path, typically the parent of the module loader package).</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Module Loader</strong> &#8211; This is the JavaScript code that resolves and loads modules and their associated dependencies, interacts with plugins, and handles configuration.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Package</strong> &#8211; A collection of modules grouped together. For example, dojo, dijit, and dgrid are packages.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Builder</strong> &#8211; This is  a tool that will generate a concatenated JavaScript file composed of a module (or modules) and its dependencies, thus making it possible to take an application composed of numerous modules and create a number of built layers that can be loaded in a minimal number of HTTP requests.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Layer</strong> &#8211; A file that contains modules that have been optimized into a single file by a Builder.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Dependency</strong> &#8211; This is a module that must be loaded for another module to function properly.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>AMD</strong> &#8211; Asynchronous Module Definition, a module format optimized for browser usage.</li>\\n<li style=\\\"margin-bottom: 1.2em;\\\"><strong>Factory</strong> &#8211; The function provided to the module loader via define that is to be executed once all the dependencies are ready</li>\\n</ul>\\n</div>\\n<div>\\n<h2>Why AMD Modules?</h2>\\n<p>The basic premise of a module system is to:</p>\\n<ul>\\n<li>allow the creation of encapsulated segments of code, called modules</li>\\n<li>define dependencies on other modules</li>\\n<li>define exported functionality that can in turn be used by other modules</li>\\n<li>discreetly access the functionality provided by these modules</li>\\n</ul>\\n<p>AMD satisfies this need, and uses a callback function with dependencies as arguments so that dependencies can be asynchronously loaded before the module code is executed. AMD also provides a plugin system for loading non-AMD resources.</p>\\n<p>While alternate methods can be used to load JavaScript (XHR + eval), using script elements to load JavaScript has an edge in performance, eases debugging (particularly on older browsers), and has cross-domain support. Thus AMD aims to provide an optimal development experience in the browser.</p>\\n<p>The AMD format provides several key benefits. First, it provides a compact declaration of dependencies. Dependencies are defined in a simple array of strings, making it easy to list numerous dependencies with little overhead.</p>\\n<p>AMD helps eliminate the need for globals. Each module defines dependencies and exports by referencing them with local variables or return objects. Consequently, modules can define functionality and interact with other modules without having to introduce any global variables. AMD is also &#8220;anonymous&#8221;, meaning that the module does not have to hard-code any references to its own path, the module name relies solely on its file name and directory path, greatly easing any refactoring efforts.</p>\\n<p>By coupling dependencies with local variables, AMD encourages high-performance coding practices. Without an AMD module loader, JavaScript code has traditionally relied on the nested objects to &#8220;namespace&#8221; functionality of a given script or module. With this approach, functions are typically accessed through a set of properties, resulting in a global variable lookup and numerous property lookups, adding extra overhead and slowing down the application. With dependencies matched to local variables, functions are typically accessed from a single local variable, which is extremely fast and can be highly optimized by JavaScript engines.</p>\\n<h1>Using AMD</h1>\\n<p>The foundational AMD API is the <code>define()</code> method which allows us to define a module and its dependencies. The API for writing modules consists of:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">define(dependencyIds, function(dependency1, dependency2,...){\\r\\n   // module code\\r\\n});</pre>\\n<p>The <code>dependencyIds</code> argument is an array of strings that indicates the dependencies to be loaded. These dependencies will be loaded and executed. Once they have all been executed, their export will be provided as the arguments to the callback function (the second argument to <code>define()</code>).</p>\\n<p>To demonstrate basic usage of AMD, here we could define a module that utilizes the <code>dojo/query</code> (CSS selector query) and <code>dojo/on</code> (event handling) modules:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndefine([&quot;dojo/query&quot;, &quot;dojo/on&quot;\\r\\n], function (query, on) {\\r\\n\\treturn {\\r\\n\\t\\tflashHeaderOnClick: function(button){\\r\\n\\t\\t\\ton(button, &quot;click&quot;, function () {\\r\\n\\t\\t\\t\\tquery(&quot;.header&quot;).style(&quot;color&quot;, &quot;red&quot;);\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\t};\\r\\n});\\r\\n</pre>\\n<p>Once dojo/query and dojo/on are loaded (which doesn&#8217;t happen until their dependencies are loaded, and so on), the callback function is called, with the <code>query</code> argument given the export of <code>dojo/query</code> (a function that does CSS selector querying), and the <code>on</code> argument given the export of <code>dojo/on</code> (a function that adds an event listener). The callback function (also known as the module factory function), is guaranteed to be called only once.</p>\\n<p>Each of the module ids listed in the set of dependencies is an abstract module path. It is abstract because it is translated to a real URL by the module loader. As you can see the module path does not need to include the &#8220;.js&#8221; suffix, this is automatically appended. When the module id starts with a name, this name is considered to be an absolute module id. In contrast, we can specify relative ids by starting with a &#8220;./&#8221; or a &#8220;../&#8221; to indicate a sibling path or parent path, respectively. These are resolved to their absolute module ids  by standard path resolution rules. You can then define a module path rule to determine how these module paths are converted to URLs. By default, the module root path is defined relative to the parent of the module loader package. For example, if we loaded Dojo like (note that we set async to true to enable true async loading of AMD):</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">&lt;script src=&quot;/path/to/dojo/dojo.js&quot; data-dojo-config=&quot;async:true&quot;&gt;\\r\\n&lt;/script&gt;</pre>\\n<p>Then the root path to modules would be assumed to be &#8220;/path/to/&#8221;. If we specified a dependency of &#8220;my/module&#8221;, this would be resolve to &#8220;/path/to/my/module.js&#8221;.</p>\\n<h2>Initial Module Loading</h2>\\n<p>We have described how to create a simple module. However, we need an entry point to trigger the chain of dependencies. We can do this by using the <code>require()</code> API. The signature of this function is basically the same as <code>define()</code>, but is used to load dependencies without defining a module (when a module is defined, it is not executed until it is required by something else). We could load our application code like:</p>\\n<pre class=\\\"brush: xml; title: ; notranslate\\\" title=\\\"\\\">\\r\\n&lt;script src=&quot;/path/to/dojo/dojo.js&quot; data-dojo-config=&quot;async:true&quot;&gt;\\r\\n&lt;script&gt;\\r\\nrequire([&quot;my/app&quot;], function(){\\t \\r\\n\\tconsole.log(&quot;application loaded!&quot;);\\t \\r\\n});\\r\\n&lt;/script&gt;\\r\\n</pre>\\n<p>Dojo provides a shortcut for loading an initial module. The initial module can be loaded by specifying the module in the <code>deps</code> configuration option:</p>\\n<pre class=\\\"brush: xml; title: ; notranslate\\\" title=\\\"\\\">\\r\\n&lt;script src=&quot;/path/to/dojo/dojo.js&quot;\\r\\n\\tdata-dojo-config=&quot;async:true, deps:['my/app']&quot;&gt;\\r\\n&lt;/script&gt;</pre>\\n<p>This is an excellent way of loading your application because JavaScript code can be completely eliminated in HTML, and only a single script tag is needed to bootstrap the rest of the application. This also makes it very easy to create aggressive builds that combine your application code and dojo.js code in a single file without having to alter the HTML script tags after the build. RequireJS and other module loaders have similar options for loading the top level modules.</p>\\n<div style=\\\"margin: 1.5em 0;\\\"><a href=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/module-loading1.png\\\"><img class=\\\"alignleft size-full wp-image-4818\\\" style=\\\"width: 500px;\\\" title=\\\"module loading\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/module-loading1.png\\\" alt=\\\"\\\" /></a></div>\\n<p>The progression of dependency loading from the <code>require()</code> call to the modules is illustrated in the diagram above. The <code>require()</code> call kicks off the loading of the first module, and dependencies are loaded as needed. Modules that are not needed (&#8220;module-d&#8221; in the diagram) are never loaded or executed.</p>\\n<p>The <code>require()</code> function can also be used to configure the module path look-ups, and other options, but these are generally specific to the module loader, and more information on configuration details are available in each loader&#8217;s documentation.</p>\\n<h2>Plugins and Dojo Optimizations</h2>\\n<p>AMD also supports plugins for loading alternate resources. This is extremely valuable for loading non-AMD dependencies like HTML snippets and templates, CSS, and internationalized locale-specific resources. Plugins allow us to reference these non-AMD resources in the dependency list. The syntax for this is:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">&quot;plugin!resource-name&quot;</pre>\\n<p>A commonly used plugin is the <code>dojo/text</code> plugin which allows you to directly load a file as text. With this plugin, we list the target file as the resource name. This is frequently used by widgets to load their HTML template. For example, with Dojo we can create our own widget like this:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndefine([&quot;dojo/_base/declare&quot;, &quot;dijit/_WidgetBase&quot;,\\r\\n\\t&quot;dijit/_TemplatedMixin&quot;,\\r\\n\\t&quot;dojo/text!./templates/foo.html&quot;\\r\\n], function(declare, _WidgetBase, _TemplatedMixin, template){\\r\\n\\treturn declare([_WidgetBase, _TemplatedMixin], {\\r\\n\\t\\ttemplateString: template\\r\\n\\t});\\r\\n});\\r\\n</pre>\\n<p>This example is instructive on multiple levels for creating Dojo widgets. First, this represents the basic boilerplate for creating a widget using the Dijit infrastructure. You might also note how we created a widget class and returned it. The <code>declare()</code> (class constructor) was used without any namespace or class name. As AMD eliminates the need for namespaces, we no longer need to create global class names with <code>declare()</code>. This aligns with a general strategy in AMD modules of writing anonymous modules. Again, an anonymous module is one that does not have any hardcoded references to its own path or name within the module itself and we could easily rename this module or move it to a different path without having to alter any code inside the module. Using this approach is generally recommended, however if you will be using this widget with declarative markup, you will still need to include namespace/class names in order to create a namespaced global for Dojo&#8217;s parser to reference in Dojo 1.7. Improvements coming in Dojo 1.8 allow you to use module ids.</p>\\n<p>There are several other plugins that are included with Dojo that are useful. The <code>dojo/i18n</code> plugin is used to load internationalized locale-specific bundles (often used for translated text or regional formatting information). Another important plugin is <code>dojo/domReady</code>, which is recommended to be used as a replacement for dojo.ready. This plugin makes it very simple to write a module that also waits for the DOM to be ready, in addition to all other dependent modules, without having to include an extra callback level. We use <code>dojo/domReady</code> as a plugin, but no resource name is needed:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">define([&quot;dojo/query&quot;, &quot;dojo/domReady!&quot;\\r\\n], function(query){\\r\\n\\t// DOM is ready, so we can query away\\r\\n\\tquery(&quot;.some-class&quot;).forEach(function(node){\\r\\n\\t\\t// do something with these nodes\\r\\n\\t});\\r\\n});</pre>\\n<p>Another valuable plugin is <code>dojo/has</code>. This module is used to assist with feature detection, allowing you to choose different code paths based on the presence of certain browser features. While this module is often used as a standard module, providing a <code>has()</code> function to the module, it can also be used as a plugin. Using it as a plugin allows us to conditionally load dependencies based on a feature presence. The syntax for the <code>dojo/has</code> plugin is to use a ternary operator with conditions as feature names and module ids as values. For example, we could load a separate touch UI module if the browser supports touch (events) like:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndefine([&quot;dojo/has!touch?ui/touch:ui/desktop&quot;\\r\\n], function(ui){\\r\\n\\t// ui will be ui/touch if touch is enabled,\\r\\n\\t//and ui/desktop otherwise\\r\\n\\tui.start();\\r\\n});</pre>\\n<p>The ternary operators can be nested, and empty strings can be used to indicate no module should be loaded.</p>\\n<p>The benefit of using <code>dojo/has</code> is more than just a run-time API for feature detection. By using <code>dojo/has</code>, both in <code>has()</code> form in your code, as well as a dependency plugin, the build system can detect these feature branches. This means that we can easily create device or browser specific builds that are highly optimized for specific feature sets, simply by defining the expected features with the <code>staticHasFeatures</code> option in the build, and the code branches will automatically be handled correctly.</p>\\n<h2>Data Modules</h2>\\n<p>For modules that do not have any dependencies, and are simply defined as an object (like just data), one can use a single argument <code>define()</code> call, where the argument is the object. This is very simple and straightforward:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">define({\\r\\n    foo: &quot;bar&quot;\\r\\n});</pre>\\n<p>This is actually similar to JSONP, enabling script-based transmission of JSON data. But, AMD actually has an advantage over JSONP in that it does not require any URL parameters; the target can be a static file without any need for active code on the server to prefix the data with a parameterized callback function. However, this technique must be used with caution as well. Module loaders always cache the modules, so subsequent <code>require()</code>&#8216;s for the same module id will yield the same cached data. This may or may not be an issue for your data retrieval needs.</p>\\n<h2>Builds</h2>\\n<p>AMD is designed to be easily parsed by build tools to create concatenated or combined sets of modules in a single file. Module systems provide a tremendous advantage in this area because build tools can automatically generate a single file based on the dependencies listed in the modules, without requiring manually written and updated lists of script files to be built. Builds dramatically reduce load time by reducing requests, and this is an easy step with AMD because the dependencies are specifically listed in the code.</p>\\n<h3>Without build</h3>\\n<p><a href=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/waterfall2.png\\\"><img class=\\\"size-full wp-image-4815\\\" title=\\\"waterfall2\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/waterfall2.png\\\" alt=\\\"\\\" width=\\\"531\\\" height=\\\"179\\\" /></a></p>\\n<h3>With build</h3>\\n<p><a href=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/waterfall3.png\\\"><img class=\\\"size-full wp-image-4816\\\" title=\\\"waterfall3\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2012/06/waterfall3.png\\\" alt=\\\"\\\" width=\\\"533\\\" height=\\\"280\\\" /></a></p>\\n<h2>Performance</h2>\\n<p>As noted before, using script element injection is faster than alternate methods because it relies more closely on native browser script loading mechanisms. We setup some tests on dojo.js in different modes, and script element loading was about 60-90% faster than using XHR with eval. In Chrome, with numerous small modules, each module was loaded in about 5-6ms, whereas XHR + eval was closer to 9-10ms per module. In Firefox, synchronous XHR was faster than asynchronous, and in IE asynchronous XHR was faster than synchronous, but script element loading is definitely the fastest. It is also surprising that IE9 was the fastest, but this is probably at least partly due to Firefox and Chrome&#8217;s debugger/inspector adding more overhead.</p>\\n<p><a href=\\\"https://wp.sitepen.com/wp-content/uploads/2012/05/module-loading-performance.png\\\"><img class=\\\"alignleft size-full wp-image-4552\\\" title=\\\"module loading performance\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2012/05/module-loading-performance.png\\\" alt=\\\"\\\" /></a></p>\\n<h2>Module Loaders</h2>\\n<p>The AMD API is open, and there are multiple AMD module loader and builder implementations that exist. Here are some key AMD loaders that are available:</p>\\n<ul>\\n<li><a href=\\\"http://dojotoolkit.org/\\\">Dojo</a> &#8211; This is a full AMD loader with plugins and a builder, and this is what we typically use since we utilize the rest of the Dojo toolkit.</li>\\n<li><a href=\\\"http://requirejs.org/\\\">RequireJS</a> &#8211; This is the original AMD loader and is the quintessential AMD loader. The author, James Burke, was the main author and advocate of AMD. This is full-featured and includes a builder.</li>\\n<li><a href=\\\"https://github.com/cujojs/curl\\\">curl.js</a> &#8211; This is a fast AMD loader with excellent plugin support (and its own library of plugins) and its own builder.</li>\\n<li><a href=\\\"https://github.com/zazl/lsjs\\\">lsjs</a> &#8211; An AMD module loader specifically designed to cache modules in local storage. The author has also built an independent optimizer.</li>\\n<li><a href=\\\"https://github.com/gigafied/NeedsJS\\\">NeedJS</a> &#8211; A light AMD module loader.</li>\\n<li><a href=\\\"https://github.com/weepy/brequire\\\">brequire</a> &#8211; Another light AMD module loader.</li>\\n<li><a href=\\\"https://github.com/linkedin/inject\\\">inject</a> &#8211; This was created and is used by LinkedIn. This is a fast and light loader without plugin support.</li>\\n<li><a href=\\\"http://tagneto.blogspot.com/2011/08/almond-small-amd-shim-loader.html\\\">Almond</a> &#8211; This is a lightweight version of RequireJS.</li>\\n</ul>\\n<h2>Getting AMD Modules</h2>\\n<p>There is an increasing number of packages and modules that are available in AMD format. The <a href=\\\"http://packages.dojofoundation.org/\\\">Dojo Foundation packages site</a> provides a central place to see a list of some of the packages that are available. The <a href=\\\"http://github.com/kriszyp/cpm\\\">CPM installer</a> can be used to install any of the packages (along with automatically installing the dependencies) that have been registered through the Dojo Foundation packages site.<br />\\n<a href=\\\"https://wp.sitepen.com/wp-content/uploads/2012/05/dfpackages.png\\\"><img class=\\\"size-full wp-image-4546\\\" title=\\\"dfpackages\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2012/05/dfpackages.png\\\" alt=\\\"\\\" width=\\\"485\\\" height=\\\"295\\\" /></a></p>\\n<p>Alternately, James Burke, the author of RequireJS has created <a href=\\\"https://github.com/volojs/volo\\\">Volo</a>, a package installer that can be used to easily install packages directly from github. Naturally, you can also simply download modules directly from their project site (on github or otherwise) and organize your directory structure yourself.</p>\\n<p>With AMD, we can easily build applications with any package, not just Dojo modules. It is also generally fairly simple to convert plain scripts to AMD. You simply add a <code>define()</code> with an empty array, and enclose the script in the callback function. You can also add dependencies, if the script must be executed after other scripts. For example:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">my-script.js:\\r\\n// add this to top of the script\\r\\ndefined([], function(){\\r\\n// existing script\\r\\n...\\r\\n// add this to the end of script\\r\\n});</pre>\\n<p>And we could build application components that pull modules from various sources:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">require([&quot;dgrid/Grid&quot;, &quot;dojo/query&quot;, &quot;my-script&quot;], function(Grid, query){\\r\\n    new Grid(config, query(&quot;#grid&quot;)[0]);\\r\\n});</pre>\\n<p>One caveat to be aware of when converting scripts to modules is that if the script has top level functions or variables, these would ordinarily result in globals, but inside of a <code>define()</code> callback they would be local to the callback function, and no globals will be created. You can either alter the code to explicitly create a global (remove the <code>var</code> or <code>function</code> prefix (you would probably want to do this if you need the script to continue working with other scripts that rely on the globals that it produces), or alter the module to return the functions or values as exports and arrange the dependent modules to use those exports (rather than the globals, this allows you to pursue the global-free paradigm of AMD).</p>\\n<h2>Directly Loading Non-AMD Scripts</h2>\\n<p>Most module loaders also support direct loading of non-AMD scripts. We can include a plain script in our dependencies, and denote that they are not AMD by suffixing them with &#8220;.js&#8221; or providing an absolute URL or a URL that starts with a slash. The loaded script will not be able to provide any direct AMD exports, but must provide its functionality through the standard means of creating global variables or functions. For example, we could load Dojo and jQuery:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">require([&quot;dojo&quot;, &quot;jquery.js&quot;], function(dojo){ // jquery will be loaded as plain script\\r\\n    dojo.query(...); // the dojo exports will be available in the &quot;dojo&quot; local variable\\r\\n    $(...);   // the other script will need to create globals\\r\\n});</pre>\\n<h2>Keep It Small</h2>\\n<p>AMD makes it easy to coordinate and combine multiple libraries. However, while it may be convenient to do this, you should exercise some caution. Combining libraries like Dojo and jQuery may function properly, but it adds a lot of extra superfluous bytes to download since Dojo and jQuery have mostly overlapping functionality. In fact, a key part of Dojo&#8217;s new module strategy is to avoid any downloading of unnecessary code. Along with converting to AMD, the Dojo base functionality has been split into various modules that can be individually used, making it possible to use the minimal subset of Dojo that is needed for a given application. In fact, modern Dojo application and component development  (like <a href=\\\"https://www.sitepen.com/blog/category/dgrid/\\\">dgrid</a>) often can lead to an entire application that is smaller than earlier versions of Dojo base by itself.</p>\\n<h2>AMD Objections</h2>\\n<p>There have been a few objections raised to AMD. One objection is that using the original CommonJS format, from which AMD is somewhat derived, is simpler, more concise, and less error prone. The CommonJS format does indeed have less ceremony. However, there are some challenges with this format. We can choose to leave the source files unaltered and directly delivered to the browser. This requires the module loader to wrap the code with a header that injects the necessary CommonJS variables, and thus relies on XHR and eval. The disadvantages of this approach have already been discussed, and include slower performance, difficult with debugging on older browsers, and cross-domain restrictions. Alternately, one can have a real-time build process, or on-request wrapping mechanism on the server, that essentially wraps the CommonJS module with the necessary wrapper, which actually can conform to AMD. These approaches are not necessarily showstoppers in many situations, and can be very legitimate development approaches. But to satisfy the broadest range of users, where users may be working on a very simple web server, or dealing with cross-browser, or older browsers, AMD decreases the chance of any of these issues becoming an obstacle for the widest range of users, a key goal of Dojo.</p>\\n<p>The dependency listing mechanism in AMD specifically has been criticized as being error prone because there are two separate lists (the list of dependencies and the callback arguments that define the variables assigned the dependencies) that must be maintained and kept in sync. If these lists become out of sync the module references are completely wrong. In practice, we haven&#8217;t experienced much difficulty with this issue, but there is an alternate way of using AMD that addresses this issue. AMD supports calling <code>define()</code> with a single callback argument where the factory function contains <code>require()</code> calls rather than a dependency list. This actually can not only help mitigate dependency list synchronization issues, but also can make it extremely easy to add CommonJS wrappers, since the factory function&#8217;s body essentially conforms to the CommonJS module format. Here is an example of how to define a module with this approach:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">define(function(require){\\r\\n    var query = require(&quot;dojo/query&quot;);\\r\\n    var on = require(&quot;dojo/on&quot;);\\r\\n    ...\\r\\n});</pre>\\n<p>When a single argument is provided, require, exports and module are automatically provided to the factory. The AMD module loader will scan the factory function for require calls, and automatically load them prior to running the factory function. Because the require calls are directly inline with the variable assignment, I could easily delete one of the dependency declarations without any further need to synchronize lists.</p>\\n<p>A quick note about the <code>require()</code> API: When <code>require()</code> is called with a single string it is executed synchronously, but when called with an array it is executed asynchronously. The dependent modules in this example are still loaded asynchronously, prior to executing the callback function, at which time dependencies are in memory, and the single string require calls in the code can be executed synchronously without issue or blocking.</p>\\n<h3>Limitations</h3>\\n<p>AMD gives us an important level of interoperability of module loading. However, AMD is just a module definition, it does not make any prescriptions on the API&#8217;s that the module create. For example, one can&#8217;t simply ask the module loader for a query engine and expect to return the functionality from interchangeable query modules with a single universal API. There may be benefit to defining such APIs for better module interchange, but that is beyond the scope of AMD. And most module loaders do support mapping module ids to different paths, so it would be very feasible to map a generic module id to different target paths if you had interchangeable modules.</p>\\n<h3>Progressive Loading</h3>\\n<p>The biggest issue that we have seen with AMD is not so much a problem with the API, but in practice there seems to be an overwhelming tendency to declare all dependencies up front (and that is all we have described so far in this post, so we are just as guilty!). However, many modules can operate correctly while deferring the loading of certain dependencies until they are actually needed. Using a deferred loading strategy can be very valuable for providing a progressively loaded page. With a progressive loading page, components can be displayed as each one is downloaded, rather than forcing the download of every byte of JavaScript before the page is rendered and usable. We can code our modules in a way to defer loading of certain modules by using the asynchronous require([]) API in the code. In this example, we only load the necessary code for this function to create children container nodes for immediate visual interaction, but then defer the loading of the widgets that go inside the containers:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">// declare modules that we need up front\\r\\ndefine([&quot;dojo/dom-create&quot;, &quot;require&quot;\\r\\n], function(domCreate, require){\\r\\n    return function(node){\\r\\n       // create container elements for our widget right away,\\r\\n       // these could be styled for the right width and height,\\r\\n       // and even contain a spinner to indicate the widgets are loading\\r\\n       var slider = domCreate(&quot;div&quot;, {className:&quot;slider&quot;}, node);\\r\\n       var progress = domCreate(&quot;div&quot;, {className:&quot;progress&quot;}, node);\\r\\n       // now load the widgets, we load them independently\\r\\n       // so each one can be rendered as it downloads\\r\\n       require([&quot;dijit/form/HorizontalSlider&quot;], function(Slider){\\r\\n          new Slider({}, slider);\\r\\n       });\\r\\n       require([&quot;dijit/Progress&quot;], function(Progress){\\r\\n          new Progress({}, progress);\\r\\n       });\\r\\n    }\\r\\n});</pre>\\n<p>This provides an excellent user experience because they interact with components as they become available, rather than having to wait for the entire application to load. Users are also more likely to feel like an application is fast and responsive if they can see the page progressively rendering.</p>\\n<h2>require, exports</h2>\\n<p>In the example above, we use a special dependency &#8220;require&#8221;, which give us a reference to a module-local <code>require()</code> function, allowing us to use a module reference relative to the current module (if you use the global &#8220;require&#8221;, relative module ids won&#8217;t be relative to the current module).</p>\\n<p>Another special dependency is &#8220;exports&#8221;. With exports, rather than returning the exported functionality, the export object is provided in the arguments, and the module can add properties to the exports object. This is particularly useful with modules that have circular references because the module factory function can start running, and add exports, and another function utilize the factory&#8217;s export before it is finished. A simple example of using &#8220;exports&#8221; in a circular reference:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">main.js:\\r\\ndefine([&quot;component&quot;, &quot;exports&quot;\\r\\n], function(component, exports){\\r\\n    // we define our exported values on the exports\\r\\n    // which may be used before this factory is called\\r\\n    exports.config = {\\r\\n       title: &quot;test&quot;\\r\\n    };\\r\\n    exports.start = function(){\\r\\n        new component.Widget();\\r\\n    };\\r\\n});\\r\\ncomponent.js:\\r\\ndefine([&quot;main&quot;, &quot;exports&quot;, &quot;dojo/_base/declare&quot;],\\r\\n        function(main, exports, declare){\\r\\n    // again, we define our exported values on the exports\\r\\n    // which may be used before this factory is called\\r\\n    exports.Widget = declare({\\r\\n        showTitle: function(){\\r\\n            alert(main.config.title);\\r\\n        }\\r\\n    });\\r\\n});</pre>\\n<p>This example would not function properly if we simply relied on the return value, because one factory function in the circular loop needs to execute first, and wouldn&#8217;t be able to access the return value from the other module.</p>\\n<p>As shown in one of the earlier examples, if the dependency list is omitted, the dependencies are assumed to be &#8220;require&#8221; and &#8220;exports&#8221;, and the <code>require()</code> calls will be scanned, so this example could be written:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">define(function(require, exports){\\r\\n    var query = require(&quot;dojo/query&quot;);\\r\\n    exports.myFunction = function(){\\r\\n       ....\\r\\n    };\\r\\n});</pre>\\n<h2>Looking Forward</h2>\\n<p>The EcmaScript committee has been working on adding native module support in JavaScript. The <a href=\\\"http://wiki.ecmascript.org/doku.php?id=harmony:modules\\\">proposed addition</a> is based on new syntax in the JavaScript language for defining and referencing modules. The new syntax includes a <code>module</code> keyword for defining modules in scripts, an <code>export</code> keyword defining exports, and an <code>import</code> keyword for defining the module properties to be imported. These operators have fairly straightforward mappings to AMD, making it likely that conversion will be relatively simple. Here is an example of how this might look based upon the current proposed examples in EcmaScript Harmony, if we were to adapt the first example in this post to Harmony&#8217;s module system.</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">import {query} from &quot;dojo/query.js&quot;;\\r\\nimport {on} from &quot;dojo/on.js&quot;;\\r\\nexport function flashHeaderOnClick(button){\\r\\n    on(button, &quot;click&quot;, function(){\\r\\n       query(&quot;.header&quot;).style(&quot;color&quot;, &quot;red&quot;);\\r\\n    });\\r\\n}</pre>\\n<p>The proposed new module system includes support for <a href=\\\"http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders\\\">custom module loaders</a> that can interact with the new module system, which may also still be used to retain certain existing AMD features like plugins for non-JavaScript resources.</p>\\n<h1>Conclusion</h1>\\n<p>AMD provides a powerful module system for browser-based web applications, leveraging native browser loading for fast asynchronous loading, supporting plugins for flexible usage of heterogeneous resources, and utilizing a simple, straightforward format. With great AMD projects like Dojo, RequireJS, and others, the world of AMD is an exciting and growing opportunity for fast, interoperable JavaScript modules.\\n</p></div>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>So what is AMD? As web applications continue to grow more advanced and more heavily rely on JavaScript, there has been a growing movement towards using modules to organize code and dependencies. Modules give us a way to make clearly distinguished components and interfaces that can easily be loaded and connected to dependencies. The AMD [&hellip;]</p>\\n\",\"protected\":false},\"author\":28,\"featured_media\":4818,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[353,45,356,3,16,6],\"tags\":[354,355,83,14,273,255],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>AMD: The Definitive Source | SitePen</title>\\n<meta name=\\\"description\\\" content=\\\"So what is AMD? As web applications continue to grow more advanced and more heavily rely on JavaScript, there has been a growing movement towards using modules to organize code and dependencies. Modules give us a way to make clearly distinguished components and interfaces that can easily be loaded and connected to dependen\\\" />\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/amd-the-definitive-source/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"AMD: The Definitive Source | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"So what is AMD? As web applications continue to grow more advanced and more heavily rely on JavaScript, there has been a growing movement towards using modules to organize code and dependencies. Modules give us a way to make clearly distinguished components and interfaces that can easily be loaded and connected to dependen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/amd-the-definitive-source/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2012-06-25T21:29:02+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2019-12-11T13:46:39+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/amd-the-definitive-source/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/amd-the-definitive-source/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/amd-the-definitive-source/\\\",\\\"name\\\":\\\"AMD: The Definitive Source | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/amd-the-definitive-source/#primaryimage\\\"},\\\"datePublished\\\":\\\"2012-06-25T21:29:02+00:00\\\",\\\"dateModified\\\":\\\"2019-12-11T13:46:39+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\"},\\\"description\\\":\\\"So what is AMD? As web applications continue to grow more advanced and more heavily rely on JavaScript, there has been a growing movement towards using modules to organize code and dependencies. Modules give us a way to make clearly distinguished components and interfaces that can easily be loaded and connected to dependen\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/amd-the-definitive-source/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/4461\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=4461\"}],\"version-history\":[{\"count\":2,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/4461/revisions\"}],\"predecessor-version\":[{\"id\":19737,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/4461/revisions/19737\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/4818\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=4461\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=4461\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=4461\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=4461\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":28,\"name\":\"Kris Zyp\",\"url\":\"https://www.sitepen.com\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/kzyp/\",\"slug\":\"kzyp\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Kris Zyp, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Kris Zyp, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/kzyp/\\\",\\\"name\\\":\\\"Kris Zyp, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cache-control","max-age=2592000"],["connection","close"],["content-type","application/json; charset=UTF-8"],["date","Mon, 10 Aug 2020 15:32:41 GMT"],["expires","Wed, 09 Sep 2020 15:32:41 GMT"],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","Apache"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.21-1+0~20200807.66+debian9~1.gbp18a1c2"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}