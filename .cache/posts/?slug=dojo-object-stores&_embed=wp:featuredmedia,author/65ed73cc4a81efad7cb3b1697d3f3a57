{"value":{"body":"[{\"id\":2093,\"date\":\"2011-02-15T00:02:46\",\"date_gmt\":\"2011-02-15T07:02:46\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=2093\"},\"modified\":\"2019-12-11T05:30:39\",\"modified_gmt\":\"2019-12-11T13:30:39\",\"slug\":\"dojo-object-stores\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/dojo-object-stores/\",\"title\":{\"rendered\":\"Dojo Object Stores\"},\"content\":{\"rendered\":\"<p>Dojo 1.6 introduces a new data store API called Dojo Object Store. This new store API is based on the <a href=\\\"http://www.w3.org/TR/IndexedDB/#object-store-sync\\\">HTML5 IndexedDB object store API</a> and is designed to greatly simplify and ease the interaction and construction of Dojo stores. <a href=\\\"http://www.w3.org/html/logo/\\\"><img loading=\\\"lazy\\\" src=\\\"https://www.w3.org/html/logo/badge/html5-badge-h-storage.png\\\" style=\\\"float:left\\\" width=\\\"133\\\" height=\\\"64\\\" alt=\\\"Based on HTML5 IndexedDB\\\" title=\\\"Based on HTML5 IndexedDB\\\"></a></p>\\n<p>Update: <a href=\\\"https://github.com/SitePen/dstore\\\">dstore</a> is developing as a successor to Dojo object stores, so if you are starting a new application, you may want to look into <a href=\\\"https://github.com/SitePen/dstore\\\">this project</a>. However, this blog post still describes an important API that is widely used, and is foundational for dstore, sharing much of the same philosophy and even much of the interface.</p>\\n<p>Dojo 1.10 also includes new stores in dojox/store for local database support. Check the latest blog posts for more information about this.<br />\\n<!--more--></p>\\n<p>There are several key philosophies behind the Dojo object store API:</p>\\n<ul>\\n<li><strong>Separate UI from data concerns</strong> &#8211; This has long been the motivation for our data API. This API helps us to separate concerns and permits independent evolution of widgets and data providers.</li>\\n<li><strong>Keep it simple</strong> &#8211; You can literally create a usable store by simply creating an object instance with query() and get() methods that return objects. As you add functionality like creating new objects, you add an add() method, and for updating objects you include a put() method.</li>\\n<li><strong>Plain JavaScript Objects</strong> &#8211; Rather than using opaque items, the new object store API uses plain JavaScript objects. Once a get() method has returned an object, or a query() method has returned an array of objects, you can access and enumerate properties using standard JavaScript properties and for-in loops. Saving objects is a matter of passing a plain object to a put() method.</li>\\n<li><strong>Promise-based</strong> &#8211; The interface is the same for sync and async except sync methods directly return values and async methods return promises. Any method can choose to be sync or async (promise-returning). This greatly simplifies interaction with known synchronous stores, since callbacks aren&#8217;t needed. This also greatly simplifies the API since asynchronous concerns are separated from the interface.</li>\\n<li><strong>Simple feature discovery</strong> &#8211; No extra methods are needed to determine the feature set of a store. If you want to know if you can add new objects to a store, just check if it has an add() method; if you want to see if it is queryable, check if it has a query() method. If you want to create a read-only store, only implement the read functions (get, query, getIdentity).</li>\\n<li><strong>Layered functionality</strong> &#8211; By layering functionality, it is possible to start with a lightweight, simple store and then add functionality as needed. Dojo&#8217;s core comes with a caching wrapper (dojo/store/Cache) for improving performance and a wrapper for notification of data changes (dojo/store/Observable). These store wrapper/layer modules are optional and can be added to any other store. This makes it possible for us to keep our core stores &mdash; dojo/store/Memory and dojo/store/JsonRest &mdash; very simple and small, and makes it possible for you to easily create new stores.</li>\\n</ul>\\n<p>Dojo Object Store API is an interface between different data consumers to different data producers. This interface can have any implementation, and Dojo core comes with two key implementations that are commonly needed: <code>dojo/store/Memory</code> and <code>dojo/store/JsonRest</code>.</p>\\n<h2>Simple: <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/Memory.html\\\">dojo/store/Memory</a></h2>\\n<p>This is a very simple in-memory store. This is highly useful for quickly creating a store, particularly for smaller datasets. A Memory store can be created by simply providing a plain array of objects as the data source for this store, and then you can start querying and interacting with the store (see the <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/Memory.html\\\">Memory object store documentation</a> for more usage details).</p>\\n<p>The Memory store is a synchronous store, which means it directly returns values, making it very easy to use. For example, to retrieve an object by id:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nvar product = productStore.get(&quot;slinky&quot;);\\r\\n</pre>\\n<p>And again, the new object store returns plain objects, so we can get properties with simple property access:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nvar name = product.name;\\r\\n</pre>\\n<p>Using plain objects makes updates easy as well:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nproduct.name = &quot;New name&quot;;\\r\\nproductStore.put(product);\\r\\n</pre>\\n<p>One of the exciting new features in Dojo object stores is improved querying. Queries are made using the query() method and the returned result set provides convenient iterative methods &mdash; much like dojo.query &mdash; that can be consistently used regardless of whether the store is sync or async. Therefore, we can rely on using forEach, map, or filter methods. The memory store supports several forms of querying. First, we can query by name-value matches (like Dojo Data&#8217;s ItemFileReadStore). Here we query by category:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nstore.query({category:&quot;shoe&quot;}).forEach(function(shoe){\\r\\n  // called for each match\\r\\n});\\r\\n</pre>\\n<p>Name-value matching provides a simple, easy query mechanism, but sometimes more complex queries are needed. The Memory store also accepts functions for filtering, thus allowing arbitrarily complex queries. For example, to query by products with a price less than 10:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nstore.query(function(product){\\r\\n  return product.price &lt; 10;\\r\\n}).forEach(function(shoe){\\r\\n  // called for each match\\r\\n});\\r\\n</pre>\\n<p>We can also refer to functions by name, and they will be looked up as a method on the store:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nstore.lessThanTen = function(product){\\r\\n  return product.price &lt; 10;\\r\\n});\\r\\nstore.query(&quot;lessThanTen&quot;).forEach(function(shoe){\\r\\n  // called for each match\\r\\n});\\r\\n</pre>\\n<h2>JSON and REST: <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/JsonRest.html\\\">dojo/store/JsonRest</a></h2>\\n<p>JsonRest assumes the existence of a server-side API, and is designed for interaction with a store. This implements a solid, standards-compliant HTTP/REST client interface to a server. The dojo/store/JsonRest follows REST principles for high scalability and is well-suited for large datasets. JsonRest is an asynchronous store, and returns promises from all the operational methods that are asynchronous (the exception: getIdentity should always be synchronous).</p>\\n<p>The JsonRest object store follows much the same approach to HTTP-compliant server interaction as dojox.data.JsonRestStore. However, JsonRest has been greatly simplified in the redesign for the new store API. A JsonRest store can be created by simply providing a URL to connect to a server (see the <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/JsonRest.html\\\">JsonRest object store documentation</a> for more usage details):</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nrequire(['dojo/store/JsonRest'], function (JsonRest) {\\r\\n  store = new JsonRest({target:&quot;/Data/&quot;});\\r\\n  ...\\r\\n</pre>\\n<p>Store methods intuitively map to HTTP methods. Calling store.get(&#8220;some-id&#8221;) would result in a GET request sent to /Data/some-id and return a promise/Deferred for the result. For example:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nstore.get(&quot;some-id&quot;).then(function(someObject){\\r\\n  // use someObject\\r\\n});\\r\\n</pre>\\n<p>Calling store.remove(id) will similarly result in a DELETE request. The add(object) and put(object) methods will trigger requests too. If the object passed to put(object) (or add(object)) includes the identity property, a PUT request will be used. If the object does not include an id or the second argument (options) includes an <code>incremental</code> property set to true, a POST request will be used.</p>\\n<p>The request will include an <code>If-Match: *</code> header if options.overwrite is true or an <code>If-None-Match: *</code> header if options.overwrite is false or if add(object) is used. This communicates to the server when object creation or modification is expected.</p>\\n<h3>Normalizing sync and async</h3>\\n<p>If you are writing a widget that may be used with either a sync or an async store, we recommend leveraging dojo/when. Rather than relying on a then() method, which is only available if the store method is async, we can use dojo/when and any return value will be properly handled. For example if we were doing a get() with an unknown store, we could write:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nrequire(['dojo/when'], function (when) {\\r\\n  when(store.get(id), function(object){\\r\\n    // this function will be called with object once get() is complete, \\r\\n    // regardless of whether it returns a promise, or directly and \\r\\n    // immediately returns a value\\r\\n  });\\r\\n  ...\\r\\n</pre>\\n<p>The dojo.when() function can be used with any store method.</p>\\n<h2>Client-Side Data Caching: <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/Cache.html\\\">dojo/store/Cache</a></h2>\\n<p>In addition to the core store implementations, Dojo comes with two store wrappers. The first wrapper is dojo/store/Cache. This wrapper is called with two stores: a caching store and a master store. A typical scenario for using the Cache wrapper is using JsonRest as a master store and a Memory store as a client-side caching store. This allows you to leverage the JsonRest store for server communication of changes, while using the Memory store for caching and avoiding unnecessary HTTP requests for data. Here is an example of how we could set this up:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nrequire(['dojo/store/Memory', 'dojo/store/JsonRest', 'dojo/store/Cache'],\\r\\n    function (Memory, JsonRest, Cache) {\\r\\n  memoryStore = new Memory({});\\r\\n  restStore = new JsonRest({target:&quot;/Data/&quot;});\\r\\n  store = new Cache(restStore, memoryStore);\\r\\n  ...\\r\\n</pre>\\n<p>Now we could perform a query with our aggregate store. Here we will just query for all the objects (we can query for everything by omitting a query):</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nvar results = store.query();\\r\\n</pre>\\n<p>This will result in the response being cached in the memory store. Later we can get() an object without incurring an HTTP request:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nobject = store.get(&quot;some-id&quot;);\\r\\n</pre>\\n<p>Changes to data through put(), add(), and remove() are all reflected in the cached data. Querying generally requires finer grained application control over exactly what should be cached and what should not. Consequently, the Cache store does not attempt to automagically query against the cache. However, if you choose to query using the cache, it is trivial. Simply query the caching store, the memoryStore in our example:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nmemoryStore.query({category:&quot;shoe&quot;}).forEach(...);\\r\\n</pre>\\n<h2>Observing Data Updates: <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/Observable.html\\\">dojo/store/Observable</a></h2>\\n<p>Dojo also comes with a store wrapper/layer for adding support for notification events of data changes. The Dojo object store API takes a very different approach to notifications than the legacy Dojo Data API. The old API was problematic in that notifications were store-wide, and it was impossible to determine exactly how an event should really affect a rendered result set.</p>\\n<p>The Dojo object store solves this problem by connecting the observation of notification events to query result sets instead of the store. With the dojo/store/Observable module, you can wrap a store and the resulting store will always have &#8220;observable&#8221; result sets returned from queries. That is, the object/array/promise returned from the query() method will have an observe() method that can be called to monitor the result set for changes. See the <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/store/Observable.html\\\">Observable store wrapper documentation for the exact signature of the observe() method and callback</a>.</p>\\n<p>The Observable module makes it extremely easy to render a result set and then respond to any changes in the underlying data with real-time UI updates. Let&#8217;s look at an example. We will create an unordered list (&lt;ul&gt;) of items corresponding to objects in storage. We will first create the list, and then respond to changes:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nrequire(['dojo/store/Observable', 'dojo/dom'],\\r\\n    function (Observable, dom) {\\r\\n  // first add observable functionality to our store\\r\\n  store = new Observable(store); \\r\\n\\r\\n  var listNode = dom.byId(&quot;list&quot;);\\r\\n  var itemNodes = [];\\r\\n  // now we will do the query for data\\r\\n  var shoes = store.query({category:&quot;shoe&quot;});\\r\\n\\r\\n  // and then render each item returned\\r\\n  shoes.forEach(function(shoe){\\r\\n    // and we render each node\\r\\n    insertRow(shoe, itemNodes.length);\\r\\n  });\\r\\n\\r\\n  // now we monitor the result set for any changes\\r\\n  shoes.observe(function(object, removedFrom, insertedInto){\\r\\n    if(removedFrom &gt; -1){ // existing object removed\\r\\n      dojo.destroy(itemNodes[removedFrom]);\\r\\n      itemNodes.splice(removedFrom, 1);\\r\\n    }\\r\\n    if(insertedInto &gt; -1){ // new or updated object inserted\\r\\n      insertRow(object, insertedInto);\\r\\n    }\\r\\n  });\\r\\n  function insertRow(product, index){\\r\\n    return itemNodes.splice(index, 0, dojo.create(&quot;li&quot;,\\r\\n      {innerHTML: product.name + &quot;: &quot; + product.price}, listNode));\\r\\n  }\\r\\n</pre>\\n<p>By setting up an observing function that can remove rows and insert rows, we are properly set to respond to any changes, including additions, deletions, and object updates. The Observable module even sends index updates such that updated objects will properly be moved to a new index, if there are sort order changes within the result set. Also note that by observing the <code>shoes</code> result set in the example, we will only get updates that match the criteria for this particular result set. If an object that is updated, deleted, or added, and it does not have a category of “shoe”, no notification events will be posted for this listener. If an object was not a &#8220;shoe&#8221; before and is updated to be a &#8220;shoe&#8221;, this will trigger a notification of an addition to the result set. If an object was a &#8220;shoe&#8221; before and is updated to not be a &#8220;shoe&#8221;, this will trigger a notification of a removal from the result set.</p>\\n<p>The Observable module also adds a notify() method to stores. This is extremely useful for Comet-driven real-time applications that asynchronously receive updates from a server and wish to notify the store (and all the store&#8217;s result set listeners) of the change. Be sure to check out <a href=\\\"https://www.sitepen.com/blog/2010/10/31/dojo-websocket/\\\">Dojo Socket</a> for more details on Comet and real-time apps with Dojo 1.6</a>.</p>\\n<h2>Working with Existing Widgets and Stores</h2>\\n<p>Most of the Dijit widgets are still based on the legacy Dojo Data API. However, Dojo comes with an adapter for using a new object store with a Dojo Data-based widget. The <a href=\\\"http://dojotoolkit.org/reference-guide/dojo/data/ObjectStore.html\\\">dojo/data/ObjectStore</a> module is an adapter that accepts an object store and returns a data store. Dojo also comes with an adapter for using a legacy data store with widgets that expect an object store. The <a href=\\\"http://dojotoolkit.org/reference-guide/1.9/dojo/store/DataStore.html#dojo-store-datastore\\\">dojo/store/DataStore</a> module is an adapter that accepts a data store and returns an object store.</p>\\n<h3>Hierarchy</h3>\\n<p>The object store API defines a method for hierarchy, created by providing a getChildren(object, options) method. getChildren should be called with a parent object, and returns a set of children. The implementation of getChildren is generally application-specific, but there are a couple of common ways to implement hierarchy:</p>\\n<ul>\\n<li><strong>Objects include a &#8220;children&#8221; property with an array of children</strong> &#8211; With this approach, each object defines its children in an array, thus specifically preserving the order of children. This works well for smaller ordered data sets.</li>\\n<li><strong>Objects include a parent reference</strong> &#8211; With this approach, each object defines its parent, and we retrieve children by querying for all objects with a given parent id. This works well for larger data sets that may involve additional handling like paging or sorting.</li>\\n</ul>\\n<h2>Adapting to Other Stores</h2>\\n<p>Update: the dojox.storage are very old, legacy modules, and should probably be avoided. This section is included for historic/informative purposes. Because the store API is a common pattern, there are a number of libraries that can easily be adapted to the store API. The dojox.storage providers are a close match, except the put() signature is slightly different. This can easily be adapted:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nvar storage = dojo.delegate(dojox.storage);\\r\\nvar storage.put = function(object, options){\\r\\n  var deferred = dojo.Deferred();\\r\\n  dojox.storage.put(options.id || object.id, object, function(status){\\r\\n    if(status == dojox.storage.FAILED){\\r\\n      deferred.reject(status);\\r\\n    }else if(status == dojox.storage.SUCCESS){\\r\\n      deferred.resolve(status);\\r\\n    }\\r\\n  });\\r\\n  return deferred;\\r\\n};\\r\\n</pre>\\n<p>Or we could adapt to <a href=\\\"https://github.com/jensarps/StorageJS\\\">Jens Arps StorageJS library</a>, which uses set() instead of put():</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nvar store = dojo.delegate(storage);\\r\\nvar store.put = function(object, options){\\r\\n  return storage.set(options.id || object.id, object);\\r\\n};\\r\\n</pre>\\n<p>The StorageJS API also has an allKeys() method that could be converted to a query() method.</p>\\n<h2>Object Stores</h2>\\n<p>The new Dojo object store infrastructure has been redesigned from the ground up to incorporate the best ideas from dojo.data, standardize around HTML5 IndexedDB, simplify usage, and layer functionality. We are excited to start building applications with this new approach, and we are looking forward to the Dojo community&#8217;s feedback on this design.</p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Dojo 1.6 introduces a new data store API called Dojo Object Store. This new store API is based on the HTML5 IndexedDB object store API and is designed to greatly simplify and ease the interaction and construction of Dojo stores. Update: dstore is developing as a successor to Dojo object stores, so if you are [&hellip;]</p>\\n\",\"protected\":false},\"author\":28,\"featured_media\":17702,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[45,4],\"tags\":[331],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Dojo Object Stores | SitePen</title>\\n<meta name=\\\"description\\\" content=\\\"Dojo 1.6 introduces a new data store API called Dojo Object Store. This new store API is based on the HTML5 IndexedDB object store API and is designed to greatly simplify and ease the interaction and construction of Dojo stores.   Update: dstore is developing as a successor to Dojo object stores, so if you are starting a\\\" />\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/dojo-object-stores/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Dojo Object Stores | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"Dojo 1.6 introduces a new data store API called Dojo Object Store. This new store API is based on the HTML5 IndexedDB object store API and is designed to greatly simplify and ease the interaction and construction of Dojo stores.   Update: dstore is developing as a successor to Dojo object stores, so if you are starting a\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/dojo-object-stores/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2011-02-15T07:02:46+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2019-12-11T13:30:39+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/dojo-object-stores/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/dojo-object-stores/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/dojo-object-stores/\\\",\\\"name\\\":\\\"Dojo Object Stores | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/dojo-object-stores/#primaryimage\\\"},\\\"datePublished\\\":\\\"2011-02-15T07:02:46+00:00\\\",\\\"dateModified\\\":\\\"2019-12-11T13:30:39+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\"},\\\"description\\\":\\\"Dojo 1.6 introduces a new data store API called Dojo Object Store. This new store API is based on the HTML5 IndexedDB object store API and is designed to greatly simplify and ease the interaction and construction of Dojo stores. Update: dstore is developing as a successor to Dojo object stores, so if you are starting a\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/dojo-object-stores/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/2093\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=2093\"}],\"version-history\":[{\"count\":1,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/2093/revisions\"}],\"predecessor-version\":[{\"id\":19723,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/2093/revisions/19723\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/17702\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=2093\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=2093\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=2093\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=2093\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":28,\"name\":\"Kris Zyp\",\"url\":\"https://www.sitepen.com\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/kzyp/\",\"slug\":\"kzyp\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Kris Zyp, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Kris Zyp, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/kzyp/\\\",\\\"name\\\":\\\"Kris Zyp, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, X-WP-Nonce, Content-Disposition, Content-MD5, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages, Link"],["allow","GET"],["cache-control","max-age=2592000"],["connection","close"],["content-type","application/json; charset=UTF-8"],["date","Tue, 25 Aug 2020 13:26:43 GMT"],["expires","Thu, 24 Sep 2020 13:26:43 GMT"],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","Apache"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.21-1+0~20200807.66+debian9~1.gbp18a1c2"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}