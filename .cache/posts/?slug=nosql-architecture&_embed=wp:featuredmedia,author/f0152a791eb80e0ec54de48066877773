{"value":{"body":"[{\"id\":953,\"date\":\"2010-05-11T00:03:59\",\"date_gmt\":\"2010-05-11T07:03:59\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=953\"},\"modified\":\"2010-05-11T00:03:59\",\"modified_gmt\":\"2010-05-11T07:03:59\",\"slug\":\"nosql-architecture\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/nosql-architecture/\",\"title\":{\"rendered\":\"NoSQL Architecture\"},\"content\":{\"rendered\":\"<p>The NoSQL movement continues to gain momentum as developers continue to grow weary of traditional SQL based database management and look for advancements in storage technology. A recent <a href=\\\"http://www.vineetgupta.com/2010/01/nosql-databases-part-1-landscape.html\\\">article provided a great roundup</a> of some of the great new technologies in this area, particularly focusing on the different approaches to replication and partitioning. There are excellent new technologies available, but using a NoSQL database is not just a straight substitute for a SQL server. NoSQL changes the rules in many ways, and using a NoSQL database is best accompanied by a corresponding change in application architecture.</p>\\n<p>The NoSQL database approach is characterized by a move away from the complexity of SQL based servers. The logic of validation, access control, mapping querieable indexed data, correlating related data, conflict resolution, maintaining integrity constraints, and triggered procedures is moved out of the database layer. This enables NoSQL database engines to focus on exceptional performance and scalability. Of course, these fundamental data concerns of an application don&#8217;t go away, but rather must move to a programmatic layer. One of the key advantages of the NoSQL-driven architecture is that this logic can now be codified in our own familiar, powerful, flexible turing-complete programming languages, rather than relying on the vast assortment of complex APIs and languages in a SQL server (data column, definitions, queries, stored procedures, etc).</p>\\n<p><!--more--></p>\\n<p>In this article, we&#8217;ll explore the different aspects of data management and suggest an architecture that uses a data management tier on top of NoSQL databases, where this tier focuses on the concerns of handling and managing data like validation, relation correlation, and integrity maintenance. Further, I believe this architecture also suggests a more user-interface-focused lightweight version of the model-viewer-controller (MVC) for the next tier. I then want to demonstrate how the Persevere 2.0 framework is well suited to be a data management layer on top of NoSQL databases. Lets look at the different aspects of databases and how NoSQL engines affect our handling of data and architecture.</p>\\n<h2>Architecture with NoSQL</h2>\\n<p>In order to understand how to properly architect applications with NoSQL databases you must understand the separation of concerns between data management and data storage. The past era of SQL based databases attempted to satisfy both concerns with databases. This is very difficult, and inevitably applications would take on part of the task of data management, providing certain validation tasks and adding modeling logic. One of the key concepts of the NoSQL movement is to have DBs focus on the task of high-performance scalable data storage, and provide low-level access to a data management layer in a way that allows data management tasks to be conveniently written in the programming language of choice rather than having data management logic spread across Turing-complete application languages, SQL, and sometimes even DB-specific stored procedure languages.</p>\\n<p><img src=\\\"https://wp.sitepen.com/wp-content/uploads/2010/03/Data-Management-Architecture.png\\\" alt=\\\"Data Management Architecture\\\" title=\\\"Data Management Architecture\\\" width=\\\"539\\\" height=\\\"358\\\" class=\\\"size-full wp-image-1222\\\" /></p>\\n<h2>Complex Data Structures</h2>\\n<p>One important capability that most NoSQL databases provide is hierarchical nested structures in data entities. Hierarchical data and data with list type structures are easily described with JSON and other formats used by NoSQL databases, where multiple tables with relations would be necessary in traditional SQL databases to describe these data structures. Furthermore, JSON (or alternatives) provide a format that much more closely matches the common programming languages data structure, greatly simplifying object mapping. The ability to easily store object-style structures without impedance mismatch is a big attractant of NoSQL.</p>\\n<p>Nested data structures work elegantly in situations where the children/substructures are always accessed from within a parent document. Object oriented and RDF databases also work well with data structures that are uni-directional, one object is accessed from another, but not vice versa.  However, if the data entities may need to be individually accessed and updated or relations are bi-directional, real relations become necessary. For example, if we had a database of employees and employers, we could easily envision scenarios where we would start with an employee and want to find their employer, or start with an employer and find all their employees. It may also be desirable to individually update an employee or employer without having to worry about updating all the related entities.</p>\\n<p>In some situations, nested structures can eliminate unnecessary bi-directional relations and greatly simplify database design, but there are still critical parts of real applications where relations are essential.</p>\\n<h2>Handling Relational Data</h2>\\n<p>The NoSQL style databases has often been termed non-relational databases. This is an unfortunate term. These databases can certainly be used with data that has relations, which is actually extremely important. In fact, real data almost always has relations. Truly non-relational data management would be virtually worthless. Understanding how to deal with relations has not always been well-addressed by NoSQL discussions and is perhaps one of the most important issues for real application development on top of NoSQL databases.</p>\\n<p>The handling of relations with traditional RDBMSs is <a href=\\\"http://en.wikipedia.org/wiki/Relational_model\\\">very well understood</a>. Table structures are defined by data normalization, and data is retrieved through SQL queries that often make extensive use of joins to leverage the relations of data to aggregate information from multiple normalized tables. The benefits of normalization <a href=\\\"http://en.wikipedia.org/wiki/Database_normalization\\\">are also clear</a>. How then do we model relations and utilize them with NoSQL databases? </p>\\n<p>There are a couple approaches. First, we can retain normalization strategies and avoid any duplication of data. Alternately, we can choose to de-normalize data which can have benefits for improved query performance.</p>\\n<p>With normalized data we can preserve key invariants, making it easy to maintain consistent data, without having to worry about keeping duplicated data in sync. However, normalization can often push the burden of effort on to queries to aggregate information from multiple records and can often incur substantial performance costs. Substantial effort has been put into providing high-performance JOINs in RDBMSs to provide optimally efficient access to normalized data. However, in the NoSQL world, most DBs do not provide any ad-hoc JOIN type of query functionality. Consequently, to perform a query that aggregates information across tables often requires application level iteration, or creative use of map-reduce functions. Queries that utilize joining for filtering across different mutable records often cannot be properly addressed with map-reduce functions, and must use application level iteration.</p>\\n<p>NoSQL advocates might suggest that the lack of JOIN functionality is beneficial; it encourages de-normalization that provides much more efficient query-time data access. All aggregation happens for each (less frequent) write, thus allowing queries to avoid any O(n) aggregation operations. However, de-normalization can have serious consequences. De-normalization means that data is prone to inconsistencies. Generally, this means duplication of data; when that data is mutated, applications must rely on synchronization techniques to avoid having copies become inconsistent. This invariant can easily be violated by application code. While it is typically suitable for multiple applications to access database management servers, with de-normalized data, database access becomes fraught with invariants that must be carefully understood. </p>\\n<p>These hazards do not negate the value of database de-normalization as an optimization and scalability technique. However, with such an approach, database access should be viewed as an internal aspect of implementation rather than a reusable API. The management of data consistency becomes an integral compliment to the NoSQL storage as part of the whole database system.</p>\\n<p>The NoSQL approach is headed in the wrong direction if it is attempting to invalidate the <a href=\\\"http://en.wikipedia.org/wiki/Codd's_12_rules\\\">historic pillars of data management</a>, established by <a href=\\\"http://en.wikipedia.org/wiki/Edgar_F._Codd\\\">Edgar Codd</a>. These basic rules for maintaining consistent data are timeless, but with the proper architecture a full NoSQL-based data management system does not need to contradict these ideas. Rather it couples NoSQL data storage engines with database management logic, allowing for these rules to be fulfilled in much more natural ways. In fact, Codd himself, the undisputed father of relational databases, was <a href=\\\"http://www.pubzone.org/dblp/journals/cmgt/Codd89\\\">opposed to</a><a href=\\\"http://www.pubzone.org/dblp/journals/cmgt/Codd89a\\\"> SQL</a>. Most likely, he would find a properly architected database management application layer combined with a NoSQL storage engine to fit much closer to his ideals of a relational database then the traditional SQL database.</p>\\n<h2>Network or In-process Programmatic Interaction?</h2>\\n<p>With the vastly different approach of NoSQL servers, it is worth considering if the traditional network-based out-of-process interaction approach of SQL servers is truly optimal for NoSQL servers. Interestingly, both of the approaches to relational data point to the value of more direct in-process programmatic access to indexes rather than the traditional query-request-over-tcp style communication. JOIN style queries over normalized data is very doable with NoSQL databases, but it relies on iterating through data sets with lookups during each loop. These lookups can be very cheap at the index level, but can incur a lot of overhead at the TCP handling and query parsing level. Direct programmatic interaction with the database sidesteps the unnecessary overhead, allowing for reasonably fast ad-hoc relational queries. This does not hinder clustering or replication across multiple machines, the data management layer can be connected to the storage system on each box.</p>\\n<p>De-normalization approaches also work well with in-process programmatic access. Here the reasons are different. Now, access to the database should be funneled through a programmatic layer that handles all data synchronization needs to preserve invariants so that multiple higher level application modules can <a href=\\\"http://feneric.blogspot.com/2009/08/maintaining-data-integrity.html\\\">safely interact with the database</a> (whether programmatically or a higher level TCP/IP based communication such as HTTP). With programmatic-only access, the data can be more safely protected from access that might violate integrity expectations.</p>\\n<p>Browser vendors have also come to similar conclusions of programmatic access to indexes rather than query-based access in the W3C process to define the browser-based database API. Earlier efforts to provide browser-based databases spurred by Google Gears and later implemented in Safari were SQL-based. But the obvious growing dissatisfaction with SQL among developers and the impedance mismatches between RDBMS style data structures and JavaScript style data structures, has led the W3C, with a proposal from Oracle (and supported by Mozilla and Microsoft), to orient towards a NoSQL-style <a href=\\\"http://www.w3.org/TR/IndexedDB/\\\">indexed key-value document database API</a> modeled after the Berkeley DB API.</p>\\n<h2>Schemas/Validation</h2>\\n<p>Most NoSQL databases could also be called schema-free databases as this is often one of the most highly touted aspects of these type of databases. The key advantage of schema-free design is that it allows applications to quickly upgrade the structure of data without expensive table rewrites. It also allows for greater flexibility in storing heterogeneously structured data. But while applications may benefit greatly from freedom from storage schemas, this certainly does not eliminate the need to enforce data validity and integrity constraints.</p>\\n<p>Moving the validity/integrity enforcement to the data management layer has significant advantages. SQL databases had very limited stiff schemas, whereas we have much more flexibility enforcing constraints with a programming language. We can enforce complex rules, mix strict type enforcements on certain properties, and leave other properties free to carry various types or be optional. Validation can even employ access to external systems to verify data. By moving validation out of the storage layer, we can centralize validation in our data management layer and have the freedom to create rich data structures and evolve our applications without storage system induced limitations.</p>\\n<h2>ACID/BASE and Relaxing Consistency Constraints</h2>\\n<p>One aspect of the NoSQL movement has been a move away from trying to maintain completely perfect consistency across distributed servers (everyone has the same view of data) due to the burden this places on databases, particularly in distributed systems. The now famous <a href=\\\"http://www.julianbrowne.com/article/viewer/brewers-cap-theorem\\\">CAP theorem</a> states that of consistency, availability, and network partitioning, only two can be guaranteed at any time. Traditional relational databases have kept strict transactional semantics to preserve consistency, but many NoSQL databases are moving towards a more scalable architecture that relaxes consistency. Relaxing consistency is often called eventual consistency. This permits much more scalable distributed storage systems where writes can occur without using two phase commits or system-wide locks. </p>\\n<p>However, relaxing consistency does lead to the possibility of conflicting writes. When multiple nodes can accept modifications without expensive lock coordination, concurrent writes can occur in conflict. Databases like CouchDB will put objects into a conflict state when this occurs. However, it is inevitably the responsibility of the application to deal with these conflicts. Again, our suggested data management layer is naturally the place for the conflict resolution logic.</p>\\n<p>Data management can also be used to customize the consistency level. In general, one can implement more relaxed consistency-based replication systems on top of individual database storage systems based on stricter transactional semantics. Customized replication and consistency enforcements can be very useful for applications where some updates may require higher integrity and some may require the higher scalability of relaxed consistency.</p>\\n<p>Customizing replication can also be useful for determining exactly what constitutes a conflict. Multi-Version Concurency Control (MVCC) style conflict resolution like that of CouchDB can be very naive. MVCC assumes the precondition for any update is the version number of the previous version of the document. This certainly is not necessarily always the correct precondition, and many times unexpected inconsistent data may be due to updates that were based on other record/document states. Creating the proper update logs and correctly finding conflicts during synchronization can often involve application level design decisions that a storage can&#8217;t make on its own.</p>\\n<h2>Persevere</h2>\\n<p><a href=\\\"http://www.persvr.org/\\\">Persevere</a> is a RESTful persistence framework, <a href=\\\"https://www.sitepen.com/blog/series/ssjs/\\\">version 2.0</a> is designed for NoSQL databases while maintaining the architecture principles of the relational model, providing a solid complementary approach. Persevere&#8217;s persistence system, Perstore, uses a data store API that is actually directly modeled after W3C&#8217;s No-SQL-inspired indexed database API. Combined with Persevere&#8217;s RESTful HTTP handler (called <a href=\\\"https://www.sitepen.com/blog/2010/01/22/introducing-pintura/\\\">Pintura</a>), data can be efficiently and scalably stored in NoSQL storage engines and accessed through a data modeling logic layer that allows users to access data in familiar RESTful terms with appropriate data views, while preserving data consistency. Persevere provides <a href=\\\"https://www.sitepen.com/blog/2010/01/25/getting-started-with-pintura/\\\">JSON Schema based validation</a>, data modification, creation, and deletion handlers,  notifications, and a <a href=\\\"https://www.sitepen.com/blog/2010/03/08/object-capability-model-and-facets-in-perstorepintura/\\\">faceted-based security system</a>. </p>\\n<p>Persevere&#8217;s <a href=\\\"https://www.sitepen.com/blog/2008/11/17/evolving-schemas-with-persevere/\\\">evolutionary schema approach</a> leans on the convenience of <a href=\\\"http://json-schema.org/\\\">JSON schema</a> to provide a powerful set of validation tools. In Persevere 2.0, we can define a data model:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">var Model = require(&quot;model&quot;).Model;\\n// productStore provides the API for accessing the storage DB.\\nModel(&quot;Product&quot;, productStore, {\\n  properties: {\\n    name: String, // we can easily define type constraints\\n    price: { // we can create more sophisticated constraints\\n      type: &quot;number&quot;,\\n      miminum: 0,\\n    },\\n    productCode: {\\n      set: function(value){\\n        // or even programmatic validation\\n      }\\n    }\\n  },\\n  // note that we have not restricted additional properties from being added\\n  // we could restrict additional properties with:\\n  // additionalProperties: false\\n\\n  // we can specify different action handlers. These are optional, they will\\n  // pass through to the store if not defined.\\n  query: function(query, options){\\n    // we can specify how queries should be handled and \\n    //delivered to the storage system\\n    productStore.query(query, options\\n  },\\n  put: function(object, directives){\\n     // we could specify any access checks, or updates to other objects \\n     // that need to take place\\n     productStore.put(object, directives);\\n  }\\n});</pre>\\n<p>The <a href=\\\"https://www.sitepen.com/blog/series/ssjs/\\\">Persevere 2.0 series of articles</a> provides more information about creating data models as well as <a href=\\\"https://www.sitepen.com/blog/2010/03/08/object-capability-model-and-facets-in-perstorepintura/\\\">using facets for controlling access to data</a>.</p>\\n<h3>Persevere&#8217;s Relational Links</h3>\\n<p>Persevere also provides relation management. This is also based on the JSON Schema specification, and has a RESTful design based on the link relation mechanism that is used in HTML and Atom. JSON Schema link definitions provide a clean technique for defining bi-directional links in a way that gives link visibility to clients. Building on our product example, we could define a Manufacturer model, and link products to their manufacturers:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\nModel(&quot;Product&quot;, productStore, {\\n   properties: {\\n      ...\\n      manufacturerId: String\\n   },\\n   links: [\\n     { \\n        rel: &quot;manufacturer&quot;,\\n        href: &quot;Manufacturer/{manufacterId}&quot;\\n     }\\n   ],\\n...\\n});\\n\\nModel(&quot;Manufacturer&quot;, manufacturerStore, {\\n   properties: {\\n      name: String,\\n      id: String,\\n      ...\\n   },\\n   links: [\\n     { \\n        rel: &quot;products&quot;,\\n        href: &quot;Product/?manufacterId={id}&quot;\\n     }\\n   ]\\n});\\n</pre>\\n<p>With this definition we have explicitly defined how one can traverse back and forth (bi-directionally) between a product and a manufacturer, using a standard normalized foreign key (no extra effort in synchronizing bi-direction references).</p>\\n<h2>The New mVC</h2>\\n<p>By implementing a logically complete data management system, we have effectively implemented the &#8220;model&#8221; of the MVC architecture. This actually allows the MVC layer to stay more focused and lightweight. Rather than having to handle data modeling and management concerns, the MVC can focus on the user interface (the viewer and controller), and simply a minimal model connector that interfaces with the full model implementation, the data management layer. I&#8217;d suggest this type of user interface layer be recapitalized as mVC to denote the de-emphasis on data modeling concerns in the user interface logic. This type of architecture facilitates multiple mVC UIs connecting to a single data management system, or vice versa, a single mVC could connect to multiple data management systems, aggregating data for the user. This decoupling improves the opportunity for independent evolution of components.</p>\\n<h2>Conclusion</h2>\\n<p>The main conceptual ideas that I believe are key to the evolution of NoSQL-based architectures:</p>\\n<ul>\\n<li>Database management needs to move to a two layer architecture, separating the concerns of data modeling and data storage. Persevere demonstrates this data modeling type of framework with a web-oriented RESTful design that complements the new breed of NoSQL servers.</li>\\n<li>With this two layered approach, the data storage server should be coupled to a particular data model manager that ensures consistency and integrity. All access must go through this data model manager to protect the invariants enforced by the managerial layer.</li>\\n<li>With a coupled management layer, storage servers are most efficiently accessed through a programmatic API, preferably keeping the storage system in-process to minimize communication overhead.</li>\\n<li>The W3C Indexed Database API fits this model well, with an API that astutely abstracts the storage (including indexing storage) concerns from the data modeling concerns. This is applicable on the server just as well as the client-side. Kudos to the W3C for an excellent NoSQL-style API.</li>\\n</ul>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>The NoSQL movement continues to gain momentum as developers continue to grow weary of traditional SQL based database management and look for advancements in storage technology. A recent article provided a great roundup of some of the great new technologies in this area, particularly focusing on the different approaches to replication and partitioning. There are [&hellip;]</p>\\n\",\"protected\":false},\"author\":28,\"featured_media\":17684,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[178],\"tags\":[240,254,152,241,114,242,76],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.5 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>NoSQL Architecture | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/nosql-architecture/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"NoSQL Architecture | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"The NoSQL movement continues to gain momentum as developers continue to grow weary of traditional SQL based database management and look for advancements in storage technology. A recent article provided a great roundup of some of the great new technologies in this area, particularly focusing on the different approaches to replication and partitioning. There are [&hellip;]\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/nosql-architecture/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2010-05-11T07:03:59+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/nosql-architecture/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/nosql-architecture/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/nosql-architecture/\\\",\\\"name\\\":\\\"NoSQL Architecture | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/nosql-architecture/#primaryimage\\\"},\\\"datePublished\\\":\\\"2010-05-11T07:03:59+00:00\\\",\\\"dateModified\\\":\\\"2010-05-11T07:03:59+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\"},\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/nosql-architecture/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/953\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=953\"}],\"version-history\":[{\"count\":0,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/953/revisions\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/17684\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=953\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=953\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=953\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=953\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":28,\"name\":\"Kris Zyp\",\"url\":\"https://www.sitepen.com\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/kzyp/\",\"slug\":\"kzyp\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.5 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Kris Zyp, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Kris Zyp, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/kzyp/\\\",\\\"name\\\":\\\"Kris Zyp, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cf-cache-status","DYNAMIC"],["cf-ray","5b01ab51fe6f06ae-LHR"],["cf-request-id","03d4e9673a000006ae20b08200000001"],["connection","close"],["content-encoding","gzip"],["content-type","application/json; charset=UTF-8"],["date","Thu, 09 Jul 2020 11:22:48 GMT"],["expect-ct","max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\""],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","cloudflare"],["set-cookie","__cfduid=deb9dabdb8e057502f58d1ea1a75a05661594293767; expires=Sat, 08-Aug-20 11:22:47 GMT; path=/; domain=.sitepen.com; HttpOnly; SameSite=Lax"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.16-1+0~20200320.56+debian9~1.gbp370a75"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}