{"value":{"body":"[{\"id\":24115,\"date\":\"2020-08-06T08:00:00\",\"date_gmt\":\"2020-08-06T15:00:00\",\"guid\":{\"rendered\":\"https://wp.sitepen.com/?p=24115\"},\"modified\":\"2020-08-06T09:41:42\",\"modified_gmt\":\"2020-08-06T16:41:42\",\"slug\":\"architecture-spotlight-event-sourcing-part-two\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/\",\"title\":{\"rendered\":\"Architecture Spotlight: Event Sourcing – Part Two\"},\"content\":{\"rendered\":\"\\n<h2><strong>Where We Left Off Previously</strong></h2>\\n\\n\\n\\n<p>In the previous <a href=\\\"https://www.sitepen.com/blog/architecture-spotlight-event-sourcing/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">architecture spotlight entry</a>, we discussed Event Sourcing and illustrated the concept with a simple banking account example. We laid out many of its pros and cons to help readers decide if the pattern would be useful to them.</p>\\n\\n\\n\\n<p>In this post, we will be expanding the example and showing a working code implementation using a popular event streaming technology, <a href=\\\"https://kafka.apache.org/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Apache Kafka</a>.</p>\\n\\n\\n\\n<h2><strong>Why Kafka?</strong></h2>\\n\\n\\n\\n<p>Kafka provides persistent messaging infrastructure and key/value data storage, supporting both event sourcing and derived state storage within a single package. These are the two primary pillars that make up a real-world event sourcing application. Kafka’s central construct of a messaging topic is used to support both concepts &#8211; its storage APIs act as a higher-level construct on top of its topic APIs.</p>\\n\\n\\n\\n<p>However, event sourcing is <a href=\\\"https://kafka.apache.org/uses\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">not Kafka’s only use-case</a>. It was originally designed to support event streaming &#8211; high-volume messaging, processing and analytics &#8211; so also works well as the general messaging fabric within your microservice system. It is easily scalable, and through its scalability, provides partitioned, replicated storage for the messages you send through it.</p>\\n\\n\\n\\n<h2><strong>Scaffolding the Basic Example</strong></h2>\\n\\n\\n\\n<p>We opt for a couple of abstractions to reduce boilerplate and allow us to focus on the event sourcing implementation. We will be using <a href=\\\"https://spring.io/projects/spring-cloud-stream\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Spring Cloud Stream</a> to provide the basis of an integration-enabled microservice app, together with its <a href=\\\"https://github.com/spring-cloud/spring-cloud-stream-binder-kafka\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Kafka and Kafka Streams binders</a> to allow us to operate with Kafka. Input, output and processing functions within the sample application will be designed as <a href=\\\"https://spring.io/projects/spring-cloud-function\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Spring Cloud Functions</a>, both simplifying the processing code as well as allowing for easier deployment to serverless infrastructure on a cloud provider, if desired. We also use <a href=\\\"https://projectlombok.org/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Lombok</a> to reduce domain object boilerplate and to provide us with readily-available logging, as well as <a href=\\\"https://github.com/FasterXML/jackson\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">Jackson</a> to handle marshaling data to and from JSON.</p>\\n\\n\\n\\n<p>The project described in this article will be built using Spring Cloud, so the first step is to download a <a href=\\\"https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=2.2.6.RELEASE&amp;packaging=jar&amp;jvmVersion=1.8&amp;groupId=com.example&amp;artifactId=es-example&amp;name=es-example&amp;description=Event%20Sourcing%20example&amp;packageName=com.example.es-example&amp;dependencies=cloud-stream,lombok\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">project scaffold</a> from Spring Initializr. Once downloaded, edit the project’s pom.xml and add the Spring Cloud Stream Kafka binders to the project’s dependencies list:</p>\\n\\n\\n<pre class=\\\"brush: xml; title: ; notranslate\\\" title=\\\"\\\">\\n&lt;dependencies&gt;\\n    &lt;dependency&gt;\\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\\n        &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;\\n    &lt;/dependency&gt;\\n    &lt;dependency&gt;\\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\\n        &lt;artifactId&gt;spring-cloud-stream-binder-kafka-streams&lt;/artifactId&gt;\\n    &lt;/dependency&gt;\\n    ...\\n</pre>\\n\\n\\n<p>You can now build and run the project from the command line, as follows (substitute mvnw for mvnw.cmd on a Windows platform):</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-bash\\\">./mvnw clean package && java -jar target/es-example*.jar</code></pre>\\n\\n\\n\\n<p>Running this will show typical <a href=\\\"https://maven.apache.org/\\\">maven</a> build output (including test executions), then log output from the running app. To start with, the log output will consist of the spring boot logo together with a few log messages indicating initial application startup, then shutdown, as right now the application contains no runtime processing logic.</p>\\n\\n\\n\\n<h2><strong>Running Kafka</strong></h2>\\n\\n\\n\\n<p>We will also need a running Kafka instance that our application can interact with to send and receive messages, as well as to access our persistent derived-state storage.</p>\\n\\n\\n\\n<p>The easiest way to get started locally is by using docker-compose. A suitable <a href=\\\"https://github.com/spring-cloud/spring-cloud-stream-samples/blob/master/multi-functions-samples/multi-functions-kafka/docker-compose.yml\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">docker-compose.yml file is available</a> (along with several other Spring Cloud Stream Kafka examples for you to take a look at). Once you have downloaded this docker-compose.yml file to your project, simply run:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-bash\\\">docker-compose up -d</code></pre>\\n\\n\\n\\n<p>Running this will start a zookeeper instance (which Kafka requires to orchestrate its clustering), as well as Kafka itself.</p>\\n\\n\\n\\n<h2><strong>Adding the Domain Model</strong></h2>\\n\\n\\n\\n<p>Before we can add some processing logic to our example application, we will need a few domain objects to model our Commands, Events and our Bank Account Entity. These objects will represent the data we pass as messages over Kafka, as well as general state containers, and will be what our processing logic operates on.</p>\\n\\n\\n\\n<h3><strong>Entity</strong></h3>\\n\\n\\n\\n<p>The basic data entity we will deal with is a bank account, described by the BankAccount class. Note we do include an account ID here, as Kafka needs a way to correlate messages by some form of key. All messages with the same key are assumed to operate on the same data object. Newer messages could also represent the complete updated state for the specified object, depending on how your system is designed. Kafka also stores all messages with the same key together on a given node, to increase efficiency when processing the complete message history for that specific data object.</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.entities;\\n\\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\\nimport lombok.Builder;\\nimport lombok.Value;\\n\\n@Value\\n@JsonDeserialize(builder = BankAccount.BankAccountBuilder.class)\\n@Builder(builderClassName = \\\"BankAccountBuilder\\\", toBuilder = true)\\npublic class BankAccount {\\n\\n   String accountId;\\n   Long balance;\\n\\n   @JsonPOJOBuilder(withPrefix = \\\"\\\")\\n   public static class BankAccountBuilder {}\\n\\n}</code></pre>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.entities;\\n\\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\\nimport lombok.Builder;\\nimport lombok.Value;\\n\\n@Value\\n@JsonDeserialize(builder = BankAccount.BankAccountBuilder.class)\\n@Builder(builderClassName = \\\"BankAccountBuilder\\\", toBuilder = true)\\npublic class BankAccount {\\n\\n   String accountId;\\n   Long balance;\\n\\n   @JsonPOJOBuilder(withPrefix = \\\"\\\")\\n   public static class BankAccountBuilder {}\\n\\n}</code></pre>\\n\\n\\n\\n<h3><strong>Events</strong></h3>\\n\\n\\n\\n<p>We opt for a single event object together with an enum to differentiate between multiple event types, however, this is by no means the only way to model such a domain.</p>\\n\\n\\n\\n<p>The event type enum:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.events;\\n\\npublic enum AccountEventType {\\n\\n   ACCOUNT_OPENED, ACCOUNT_CREDITED, ACCOUNT_DEBITED\\n\\n}</code></pre>\\n\\n\\n\\n<p>In addition to credit and debit events, we also include <strong><em><code>ACCOUNT_OPENED</code></em></strong>. This is used as a marker to ‘open’ an account, meaning that an initial account object (with zero starting balance) is created within the system. Credit and debit events can only operate on an already-existing account.</p>\\n\\n\\n\\n<p>Account events are represented by an <code>AccountEvent</code> class:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.events;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\\nimport lombok.Builder;\\nimport lombok.Value;\\n\\n@Value\\n@JsonDeserialize(builder = AccountEvent.AccountEventBuilder.class)\\n@Builder(builderClassName = \\\"AccountEventBuilder\\\", toBuilder = true)\\npublic class AccountEvent {\\n\\n   String accountId;\\n   AccountEventType eventType;\\n   Long amount;\\n   BankAccount bankAccount;\\n\\n   @JsonPOJOBuilder(withPrefix = \\\"\\\")\\n   public static class AccountEventBuilder {}\\n\\n}</code></pre>\\n\\n\\n\\n<p>Notice the event contains a representation of the latest bank account state within it. This is only done for point-in-time processing convenience and is by no means required. With event sourcing, it’s key to remember that the sequence of all events ultimately represents the master state record. Any other state representation is purely for convenience.</p>\\n\\n\\n\\n<h3><strong>Commands</strong></h3>\\n\\n\\n\\n<p>Similar to the events, we use a single container object with an enum to differentiate between command types. The enum also contains most of the processing logic to apply a command to an account, and by doing so, generate an event.</p>\\n\\n\\n\\n<p>The command type enum:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.commands;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.model.events.AccountEvent;\\nimport com.example.esexample.model.events.AccountEventType;\\nimport lombok.extern.slf4j.Slf4j;\\n\\n@Slf4j\\npublic enum CommandType {\\n\\n   DEPOSIT {\\n       @Override\\n       protected AccountEvent processForAccount(String accountId, Long amount, BankAccount bankAccount) {\\n           validateAccountPreconditions(accountId, amount, bankAccount);\\n\\n           log.info(\\\"Processing {} (amount: {}) for account {}\\\", this, amount, bankAccount);\\n\\n           final BankAccount newAccountState = BankAccount.builder().accountId(bankAccount.getAccountId())\\n                   .balance(bankAccount.getBalance() + amount).build();\\n\\n           return AccountEvent.builder().accountId(bankAccount.getAccountId())\\n                   .eventType(AccountEventType.ACCOUNT_CREDITED).amount(amount).bankAccount(newAccountState).build();\\n       }\\n\\n       @Override\\n       protected void validateAccountPreconditions(String accountId, Long amount, BankAccount bankAccount) {\\n           if (!accountId.equals(bankAccount.getAccountId())) {\\n               throw new IllegalStateException(\\\"Command request is not for the specified account\\\");\\n           }\\n       }\\n   }, WITHDRAW {\\n       @Override\\n       protected AccountEvent processForAccount(String accountId, Long amount, BankAccount bankAccount) {\\n           validateAccountPreconditions(accountId, amount, bankAccount);\\n\\n           log.info(\\\"Processing {} (amount: {}) for account {}\\\", this, amount, bankAccount);\\n\\n           final BankAccount newAccountState = BankAccount.builder().accountId(bankAccount.getAccountId())\\n                   .balance(bankAccount.getBalance() - amount).build();\\n\\n           return AccountEvent.builder().accountId(bankAccount.getAccountId())\\n                   .eventType(AccountEventType.ACCOUNT_DEBITED).amount(amount).bankAccount(newAccountState).build();\\n       }\\n\\n       @Override\\n       protected void validateAccountPreconditions(String accountId, Long amount, BankAccount bankAccount) {\\n           if (!accountId.equals(bankAccount.getAccountId())) {\\n               throw new IllegalStateException(\\\"Withdrawal request is not for the specified account\\\");\\n           }\\n\\n           if (bankAccount.getBalance() < amount) {\\n               throw new IllegalStateException(\\\"Insufficient funds to process withdrawal request\\\");\\n           }\\n       }\\n\\n   };\\n\\n   abstract protected AccountEvent processForAccount(String accountId, Long amount, BankAccount bankAccount);\\n\\n   abstract protected void validateAccountPreconditions(String accountId, Long amount, BankAccount bankAccount);\\n\\n   boolean canProcessForAccount(String accountId, Long amount, BankAccount bankAccount) {\\n       try {\\n           validateAccountPreconditions(accountId, amount, bankAccount);\\n           return true;\\n       } catch (IllegalStateException e) {\\n           return false;\\n       }\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>Of particular interest above is the <code>validateAccountPreconditions()</code> method in the <strong><em><code>WITHDRAW</code></em></strong> enum value. This represents the business logic to check that the account into which the command is being processed contains sufficient funds for the withdrawal to succeed. An <code>IllegalStateException</code> is thrown if this condition cannot be met.</p>\\n\\n\\n\\n<p>The command container object:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.model.commands;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.model.events.AccountEvent;\\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\\nimport lombok.Builder;\\nimport lombok.Value;\\n\\n@Value\\n@JsonDeserialize(builder = Command.CommandBuilder.class)\\n@Builder(builderClassName = \\\"CommandBuilder\\\", toBuilder = true)\\npublic class Command {\\n\\n   String accountId;\\n   CommandType commandType;\\n   Long amount;\\n\\n   public boolean canProcessForAccount(BankAccount bankAccount) {\\n       return null != commandType && commandType.canProcessForAccount(accountId, amount, bankAccount);\\n   }\\n\\n   public AccountEvent processForAccount(BankAccount bankAccount) {\\n       return null == commandType ? null : commandType.processForAccount(accountId, amount, bankAccount);\\n   }\\n\\n   @JsonPOJOBuilder(withPrefix = \\\"\\\")\\n   public static class CommandBuilder {}\\n\\n}</code></pre>\\n\\n\\n\\n<h2><strong>Utility Classes</strong></h2>\\n\\n\\n\\n<p>A <code>Constants</code> class stores constants used across the app:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.util;\\n\\npublic class Constants {\\n\\n   public static final String UNITY_ACCOUNT_ID = \\\"unity\\\";\\n\\n   public static final String HEADER_ACCOUNT_ID = \\\"accountId\\\";\\n   public static final String HEADER_EVENT_TYPE = \\\"eventType\\\";\\n   public static final String HEADER_CORRELATION_UUID = \\\"correlationUuid\\\";\\n\\n   public static final String EVENT_STORE_ACCOUNTS = \\\"stores.accounts\\\";\\n\\n   public static final String RESOURCE_ACCOUNT_GET_PREFIX = \\\"/account/\\\";\\n   public static final String RESOURCE_ACCOUNT_GET = RESOURCE_ACCOUNT_GET_PREFIX + \\\"{accountId}\\\";\\n\\n   private Constants() throws IllegalAccessException {\\n       throw new IllegalAccessException(\\\"Utility class\\\");\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>Of particular interest is the <strong><em><code>UNITY_ACCOUNT_ID</code> </em></strong>value. This represents the ID of the singular account we are operating on as part of this example and is only present to allow Kafka to correlate messages intended for this particular account entity.</p>\\n\\n\\n\\n<p>The <code>AccountPrinter</code> class will periodically output the current state of the bank account:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.util;\\n\\nimport com.example.esexample.service.BankAccountService;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\nimport org.springframework.web.client.RestClientException;\\nimport org.springframework.web.server.ResponseStatusException;\\n\\n@Component\\n@Slf4j\\npublic class AccountPrinter {\\n\\n   @Autowired\\n   private BankAccountService bankAccountService;\\n\\n   @Scheduled(fixedRate = 5_000)\\n   public void printAccountState() {\\n       log.info(\\\"-----------------------------------\\\");\\n       try {\\n           log.info(\\\"Account state: {}\\\", bankAccountService.getAccount(Constants.UNITY_ACCOUNT_ID));\\n       } catch (RestClientException e) {\\n           log.warn(\\n                   \\\"Account service still starting up (unable to parse response for account \\\" + Constants.UNITY_ACCOUNT_ID + \\\")\\\");\\n       } catch (ResponseStatusException e) {\\n           if (e.getStatus() == HttpStatus.SERVICE_UNAVAILABLE) {\\n               log.warn(\\\"Account [id: '{}'] not yet available\\\", Constants.UNITY_ACCOUNT_ID);\\n           } else if (e.getStatus() == HttpStatus.NOT_FOUND) {\\n               log.warn(\\\"Account [id: '{}'] not found\\\", Constants.UNITY_ACCOUNT_ID);\\n           } else {\\n               log.error(\\\"Failed to fetch account \\\" + Constants.UNITY_ACCOUNT_ID, e);\\n           }\\n       } catch (RuntimeException e) {\\n           log.error(\\\"Failed to fetch account \\\" + Constants.UNITY_ACCOUNT_ID, e);\\n       }\\n       log.info(\\\"-----------------------------------\\\");\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<h2><strong>The Service and Data Layers</strong></h2>\\n\\n\\n\\n<p>The <code>AccountPrinter</code> needs a <code>BankAccountService</code> to fetch the latest available account status:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.service;\\n\\nimport com.example.esexample.dl.BankAccountRepository;\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.util.Constants;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RequestParam;\\nimport org.springframework.web.bind.annotation.RestController;\\nimport org.springframework.web.server.ResponseStatusException;\\n\\n@RestController()\\n@Slf4j\\npublic class BankAccountService {\\n\\n   @Autowired\\n   private BankAccountRepository bankAccountRepository;\\n\\n   @RequestMapping(Constants.RESOURCE_ACCOUNT_GET)\\n   public BankAccount getAccount(@RequestParam(value = \\\"accountId\\\") String accountId) {\\n       if (null == accountId || accountId.isEmpty()) {\\n           throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \\\"No account ID specified\\\");\\n       }\\n\\n       try {\\n           final BankAccount account = bankAccountRepository.getAccount(accountId);\\n           if (account == null) {\\n               throw new ResponseStatusException(HttpStatus.NOT_FOUND, \\\"Specified account not found\\\");\\n           }\\n           return account;\\n       } catch (IllegalStateException e) {\\n           throw new ResponseStatusException(HttpStatus.SERVICE_UNAVAILABLE,\\n                   \\\"This server is currently unable to process the request - please try again later\\\");\\n       }\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>The service provides a REST endpoint to fetch an account, given its account ID. It is simply a transport wrapper around the data layer repository, which is:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.dl;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.util.Constants;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.apache.kafka.common.serialization.StringSerializer;\\nimport org.apache.kafka.streams.state.HostInfo;\\nimport org.apache.kafka.streams.state.QueryableStoreTypes;\\nimport org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.cloud.stream.binder.kafka.streams.InteractiveQueryService;\\nimport org.springframework.stereotype.Repository;\\nimport org.springframework.web.client.RestTemplate;\\n\\n@Slf4j\\n@Repository\\npublic class BankAccountRepository {\\n\\n   @Autowired\\n   private InteractiveQueryService interactiveQueryService;\\n\\n   public BankAccount getAccount(String accountId) {\\n       HostInfo hostInfo = interactiveQueryService\\n               .getHostInfo(Constants.EVENT_STORE_ACCOUNTS, accountId, new StringSerializer());\\n\\n       if (null == hostInfo || null == hostInfo.host()) {\\n           throw new IllegalStateException(\\\"Unable to determine host responsible for the account\\\");\\n       }\\n\\n       if (interactiveQueryService.getCurrentHostInfo().equals(hostInfo)) {\\n           log.debug(\\\"Fetching account from local host {}:{}\\\", hostInfo.host(), hostInfo.port());\\n           final ReadOnlyKeyValueStore<String, BankAccount> accountStore = interactiveQueryService\\n                   .getQueryableStore(Constants.EVENT_STORE_ACCOUNTS,\\n                           QueryableStoreTypes.<String, BankAccount>keyValueStore());\\n\\n           return accountStore.get(accountId);\\n       } else {\\n           log.debug(\\\"Fetching account from remote host {}:{}\\\", hostInfo.host(), hostInfo.port());\\n\\n           RestTemplate restTemplate = new RestTemplate();\\n           return restTemplate.getForEntity(String.format(\\\"http://%s:%d%s%s\\\", hostInfo.host(), hostInfo.port(),\\n                   Constants.RESOURCE_ACCOUNT_GET_PREFIX, accountId), BankAccount.class).getBody();\\n       }\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>This repository uses Kafka’s <a href=\\\"https://kafka.apache.org/24/documentation/streams/developer-guide/interactive-queries.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">interactive query service</a> to gain access to a KeyValueStore, from which the latest derived account state can be fetched. As previously mentioned, Kafka identifies and correlates data by key, storing all data for a given key locally to a given node. The repository queries for the HostInfo for the specified bank account ID - if Kafka responds that the data for the given key is being stored locally, the repository can then request a queryable key/value store through which it can fetch the account data directly.</p>\\n\\n\\n\\n<p>When scaling up and running the services and Kafka across multiple nodes, the HostInfo returned from the interactive query service may indicate that the data for the given key is being stored on an external node. In this case, the repository acts as a proxy to fetch the account data from the identified node’s REST service (specifically, its&nbsp;<code>BankAccountService.getAccount()</code> method). This topology allows for any data to be requested from any REST node, and the data layer and Kafka will, behind the scenes, orchestrate which particular service node the request is routed to, depending on where Kafka is storing the data for the specified message key.</p>\\n\\n\\n\\n<h2><strong>Message Integration and Processing Layers</strong></h2>\\n\\n\\n\\n<p>Now that we have the complete domain, data and service layers in place, we can add our message processing nodes. These will inject messages into the system (acting as simulated user input), process messages within the <a href=\\\"https://kafka.apache.org/24/documentation/streams/core-concepts#streams_topology\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">topology</a>, as well as act as persistence sinks for Kafka’s key/value stores.</p>\\n\\n\\n\\n<h3><strong>Input</strong></h3>\\n\\n\\n\\n<p>This is an account opener, which will send an initial <code>ACCOUNT_OPENED</code> event to instantiate the initial account object within Kafka’s storage:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.pipeline.input;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.model.events.AccountEvent;\\nimport com.example.esexample.model.events.AccountEventType;\\nimport com.example.esexample.service.BankAccountService;\\nimport com.example.esexample.util.Constants;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.messaging.Message;\\nimport org.springframework.messaging.support.MessageBuilder;\\nimport org.springframework.stereotype.Service;\\nimport org.springframework.web.client.RestClientException;\\nimport org.springframework.web.server.ResponseStatusException;\\n\\nimport java.util.UUID;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport java.util.function.Supplier;\\n\\n@Slf4j\\n@Service\\npublic class AccountOpener {\\n\\n   @Autowired\\n   private BankAccountService bankAccountService;\\n\\n   private AtomicBoolean accountOpened = new AtomicBoolean(false);\\n\\n   @Bean\\n   public Supplier<Message<AccountEvent>> openAccount() {\\n       return () -> {\\n           final String accountId = Constants.UNITY_ACCOUNT_ID;\\n\\n           try {\\n               bankAccountService.getAccount(accountId);\\n               return null;\\n           } catch (RestClientException e) {\\n               log.warn(\\\"Account service still starting up (unable to parse response for account \\\" + accountId + \\\")\\\");\\n               return null;\\n           } catch (ResponseStatusException e) {\\n               if (e.getStatus() != HttpStatus.NOT_FOUND) {\\n                   return null;\\n               }\\n           }\\n\\n           if (!accountOpened.compareAndSet(false, true)) {\\n               return null;\\n           }\\n           log.info(\\\"Requesting opening of account '{}'\\\", accountId);\\n\\n           final BankAccount bankAccount = BankAccount.builder().accountId(accountId).balance(0l).build();\\n\\n           final AccountEvent accountEvent = AccountEvent.builder().accountId(accountId)\\n                   .eventType(AccountEventType.ACCOUNT_OPENED).bankAccount(bankAccount).build();\\n\\n           log.info(\\\"Sending account event: {}\\\", accountEvent);\\n\\n           return MessageBuilder.withPayload(accountEvent).setHeader(\\\"messageKey\\\", accountId)\\n                   .setHeader(Constants.HEADER_ACCOUNT_ID, accountId)\\n                   .setHeader(Constants.HEADER_EVENT_TYPE, accountEvent.getEventType())\\n                   .setHeader(Constants.HEADER_CORRELATION_UUID, UUID.randomUUID().toString()).build();\\n       };\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>This is a command requestor, which simulates user input of depositing and withdrawing money from the account:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.pipeline.input;\\n\\nimport com.example.esexample.model.commands.Command;\\nimport com.example.esexample.model.commands.CommandType;\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.service.BankAccountService;\\nimport com.example.esexample.util.Constants;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.messaging.Message;\\nimport org.springframework.messaging.support.MessageBuilder;\\nimport org.springframework.stereotype.Service;\\nimport org.springframework.web.client.RestClientException;\\nimport org.springframework.web.server.ResponseStatusException;\\n\\nimport java.util.UUID;\\nimport java.util.function.Supplier;\\n\\n@Slf4j\\n@Service\\npublic class CommandRequestor {\\n\\n   @Autowired\\n   private BankAccountService bankAccountService;\\n\\n   @Bean\\n   public Supplier<Message<Command>> depositSource() {\\n       return () -> {\\n           final String accountId = Constants.UNITY_ACCOUNT_ID;\\n\\n           try {\\n               final BankAccount bankAccount = bankAccountService.getAccount(accountId);\\n               if (null == bankAccount) {\\n                   return null;\\n               }\\n           } catch (RestClientException e) {\\n               log.warn(\\\"Account service still starting up (unable to parse response for account \\\" + accountId + \\\")\\\");\\n               return null;\\n           } catch (ResponseStatusException e) {\\n               if (e.getStatus() != HttpStatus.NOT_FOUND && e.getStatus() != HttpStatus.SERVICE_UNAVAILABLE) {\\n                   return null;\\n               }\\n           }\\n\\n           Long amount = Math.round(Math.random() * 9.0d + 1.0d);\\n           Command depositRequest = Command.builder().commandType(CommandType.DEPOSIT).accountId(accountId)\\n                   .amount(amount).build();\\n\\n           log.info(\\\"Sending deposit request: {}\\\", depositRequest);\\n\\n           return MessageBuilder.withPayload(depositRequest).setHeader(Constants.HEADER_ACCOUNT_ID, accountId)\\n                   .setHeader(Constants.HEADER_CORRELATION_UUID, UUID.randomUUID().toString()).build();\\n       };\\n   }\\n\\n   @Bean\\n   public Supplier<Message<Command>> withdrawalSource() {\\n       return () -> {\\n           final String accountId = Constants.UNITY_ACCOUNT_ID;\\n\\n           try {\\n               final BankAccount bankAccount = bankAccountService.getAccount(accountId);\\n               if (null == bankAccount) {\\n                   return null;\\n               }\\n           } catch (RestClientException e) {\\n               log.warn(\\\"Account service still starting up (unable to parse response for account \\\" + accountId + \\\")\\\");\\n               return null;\\n           } catch (ResponseStatusException e) {\\n               if (e.getStatus() != HttpStatus.NOT_FOUND && e.getStatus() != HttpStatus.SERVICE_UNAVAILABLE) {\\n                   return null;\\n               }\\n           }\\n\\n           Long amount = Math.round(Math.random() * 49.0d + 1.0d);\\n           Command withdrawRequest = Command.builder().commandType(CommandType.WITHDRAW).accountId(accountId)\\n                   .amount(amount).build();\\n\\n           log.info(\\\"Sending withdrawal request: {}\\\", withdrawRequest);\\n\\n           return MessageBuilder.withPayload(withdrawRequest).setHeader(Constants.HEADER_ACCOUNT_ID, accountId)\\n                   .setHeader(Constants.HEADER_CORRELATION_UUID, UUID.randomUUID().toString()).build();\\n       };\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>The requested withdrawal amounts are five times as much as the deposit amounts, allowing for some failures to occur when insufficient funds are available. These failures will be indicated in the application’s log output when eventually running the fully working example.</p>\\n\\n\\n\\n<h3><strong>Command and Event Processing</strong></h3>\\n\\n\\n\\n<p>Let’s look in greater detail at the command handler. This delegates to the command’s business logic to check if they can be processed on the latest available account state. If they can, processing occurs and an event is generated. If processing cannot happen, <strong><code>null</code></strong> is returned instead and no event will be generated - in our processing topology we’re using <strong><code>null</code></strong> to indicate the termination of a given messaging flow.</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.pipeline.processing;\\n\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.model.events.AccountEvent;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.apache.kafka.streams.kstream.KStream;\\nimport org.apache.kafka.streams.kstream.KTable;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.function.BiFunction;\\n\\n@Service\\n@Slf4j\\npublic class EventHandler {\\n\\n   @Bean\\n   public BiFunction<KStream<String, AccountEvent>, KTable<String, BankAccount>, KStream<String, AccountEvent>> processEvent() {\\n       return (eventStream, accountTable) -> eventStream\\n               .leftJoin(accountTable, (event, bankAccount) -> null == bankAccount ? event : null)\\n               .filter((s, event) -> {\\n                   if (null != event) {\\n                       log.info(\\\"Sending account event {}\\\", event);\\n                   }\\n                   return null != event;\\n               });\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<p>Below are storage sinks, which act as terminator nodes within the messaging topology. These just log any messages they receive - the real magic of using these for persistent key/value storage is done via Spring Cloud Stream Kafka configuration:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">package com.example.esexample.pipeline.processing;\\n\\nimport com.example.esexample.model.commands.Command;\\nimport com.example.esexample.model.entities.BankAccount;\\nimport com.example.esexample.model.events.AccountEvent;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.apache.kafka.streams.kstream.KStream;\\nimport org.apache.kafka.streams.kstream.KTable;\\nimport org.springframework.context.annotation.Bean;\\n\\nimport java.util.function.Consumer;\\nimport java.util.function.Function;\\n\\n@Slf4j\\npublic class StorageSinks {\\n\\n   @Bean\\n   public Function<KStream<String, AccountEvent>, KStream<String, BankAccount>> getAccountFromEvent() {\\n       return (eventStream) -> eventStream.mapValues((s, event) -> event.getBankAccount());\\n   }\\n\\n   @Bean\\n   public Consumer<KTable<String, BankAccount>> accountStorageSink() {\\n       return accountTable -> {\\n           accountTable.mapValues((accountId, bankAccount) -> {\\n               log.info(\\\"Sinking account #{} to persistent state store: {} [{}]\\\", accountId,\\n                       accountTable.queryableStoreName(), bankAccount);\\n               return bankAccount;\\n           });\\n       };\\n   }\\n\\n   @Bean\\n   public Consumer<KTable<String, Command>> commandStorageSink() {\\n       return commandTable -> {\\n           commandTable.mapValues((accountId, command) -> {\\n               log.info(\\\"Sinking command to persistent state store: {} [{}]\\\", commandTable.queryableStoreName(),\\n                       command);\\n               return command;\\n           });\\n       };\\n   }\\n\\n}</code></pre>\\n\\n\\n\\n<h2><strong>Tying It All Together - Application Configuration</strong></h2>\\n\\n\\n\\n<p>A basic Lombok configuration file is needed to properly support our JSON serialization. Create a <code>lombok.config</code> file within the root of your <code>src/main/java</code> folder and add the following to it:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">config.stopBubbling = true\\nlombok.copyableAnnotations += com.fasterxml.jackson.annotation.JsonProperty</code></pre>\\n\\n\\n\\n<p>Now that we have all the code in place, we need to wire each individual component into a complete processing topology. This is done with an <code>application.yml</code> configuration file. Replace the <code>application.properties</code> file in your project with the <code>application.yml</code> below:</p>\\n\\n\\n\\n<pre class=\\\"wp-block-prismatic-blocks\\\"><code class=\\\"language-java\\\">spring.application.name: es-example\\n\\nspring.cloud.stream:\\n default.content-type: application/json\\n kafka:\\n   streams.binder.configuration:\\n     processing.guarantee: exactly_once\\n###############\\n# SET THIS TO A VALID HOSTNAME BEFORE RUNNING THE APP!\\n###############\\n     application.server: CHANGEME.LOCAL.HOST:8080\\n     commit.interval.ms: 1000\\n   streams.binder.stateStoreRetry.maxAttempts: 5\\n   default.producer:\\n     messageKeyExpression: headers['accountId'].getBytes('UTF-8')\\n     sync: true\\n     configuration:\\n       acks: all\\n       retries: 1\\n       enable.idempotence: true\\n       max.block.ms: 5000\\n# Enable indefinite topic message retention\\n     topic.properties.retention:\\n       ms: -1\\n       bytes: -1\\n   default.consumer.partitioned: true\\n# Which spring cloud stream processing functions should be activated at runtime\\n function.definition: openAccount;processEvent;getAccountFromEvent;accountStorageSink;commandStorageSink;depositSource;withdrawalSource;processCommand\\n bindings:\\n   openAccount-out-0.destination: source.accounts\\n   processEvent-in-0.destination: source.accounts\\n   processEvent-in-1.destination: stores.accounts\\n   processEvent-out-0.destination: events\\n   depositSource-out-0.destination: commands\\n   withdrawalSource-out-0.destination: commands\\n   processCommand-in-0.destination: commands\\n   processCommand-in-1.destination: stores.accounts\\n   processCommand-out-0.destination: events\\n   getAccountFromEvent-in-0.destination: events\\n   getAccountFromEvent-out-0.destination: stores.accounts\\n   accountStorageSink-in-0.destination: stores.accounts\\n   commandStorageSink-in-0.destination: commands\\n kafka.streams.bindings:\\n   accountStorageSink-in-0.consumer.materializedAs: stores.accounts\\n   getAccountFromEvent-in-0.consumer.materializedAs: stores.events\\n   commandStorageSink-in-0.consumer.materializedAs: stores.commands\\n# Each processor bean within a Kafka Streams topology requires a unique application ID\\n kafka.streams.binder.functions:\\n   openAccount.applicationId: openAccount\\n   processEvent.applicationId: processEvent\\n   depositSource.applicationId: depositSource\\n   withdrawalSource.applicationId: depositSource\\n   processCommand.applicationId: processCommand\\n   getAccountFromEvent.applicationId: getAccountFromEvent\\n   accountStorageSink.applicationId: accountStorageSink\\n   commandStorageSink..applicationId: commandSink</code></pre>\\n\\n\\n\\n<p>Ensure you set a value for <strong><code>application.server</code></strong> before running the app. This should correspond to your local hostname - kafka requires this to support its HostInfo routing support between multiple cluster nodes.</p>\\n\\n\\n\\n<p>The main points of interest in the config are:</p>\\n\\n\\n\\n<p><strong><code>spring.cloud.stream.function.definition</code></strong></p>\\n\\n\\n\\n<p>This indicates which of the given Spring Cloud Function processing components should be enabled within the running application. Here we are listing all the functions added so far in this example.</p>\\n\\n\\n\\n<p><strong><code>spring.cloud.stream.bindings</code></strong></p>\\n\\n\\n\\n<p>These configure our messaging topology - how all the inputs, outputs and intermediate processing functions are connected. Each named destination corresponds to a distinct Kafka topic which is used to route messages between processing functions.</p>\\n\\n\\n\\n<p><strong><code>spring.cloud.stream.kafka.streams.bindings</code></strong></p>\\n\\n\\n\\n<p>We are using our trivial storage sink functions to act as markers for named key/value stores within Kafka; these configuration options indicate which stores should be created and used. You may also notice that some of these store names are included in the <strong><code>spring.cloud.stream.bindings</code></strong> - as mentioned at the beginning of the article, Kafka’s storage APIs act as layers above its messaging topics. This means a named key/value store corresponds to a message topic, so it can also be used within the Kafka Streams message processing topology, via the <a href=\\\"https://kafka.apache.org/24/javadoc/org/apache/kafka/streams/kstream/KStream.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">KStream</a> and <a href=\\\"https://kafka.apache.org/24/javadoc/org/apache/kafka/streams/kstream/KTable.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">KTable</a> APIs. We use this mechanism within the CommandHandler, effectively joining on the latest available account data when attempting to process a command. This allows us to quickly check if a command can be processed by looking at the latest stored account state, without needing to re-process every event to determine what the current account balance is.</p>\\n\\n\\n\\n<p><strong><code>spring.cloud.stream.kafka.streams.binder.functions</code></strong></p>\\n\\n\\n\\n<p>Each spring cloud function within the application requires its own application ID for unique identification within the Kafka processing topology. With this example, we are including all processing functions within a single application - however, these would typically be separated out into their own independent microservices. For cases where a single application contains a single processing function, this configuration option can be omitted, in which case, Spring will use the main <strong><code>spring.application.name</code> </strong>config property to identify the processing function within the Kafka topology.</p>\\n\\n\\n\\n<h2><strong>System Review</strong></h2>\\n\\n\\n\\n<p>With everything now in place, we can take a step back and review the system just created. The following diagram illustrates how both a command and query will flow through and how Kafka is leveraged along the way.</p>\\n\\n\\n\\n<figure class=\\\"wp-block-image size-large\\\"><img src=\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/image1.png\\\" alt=\\\"\\\" class=\\\"wp-image-24126\\\" srcset=\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/image1.png 1999w, https://wp.sitepen.com/wp-content/uploads/2020/04/image1-300x217.png 300w, https://wp.sitepen.com/wp-content/uploads/2020/04/image1-1024x740.png 1024w, https://wp.sitepen.com/wp-content/uploads/2020/04/image1-768x555.png 768w, https://wp.sitepen.com/wp-content/uploads/2020/04/image1-1536x1110.png 1536w\\\" sizes=\\\"(max-width: 1999px) 100vw, 1999px\\\" /></figure>\\n\\n\\n\\n<p>Each event flows through a series of independent functions - the Command Handler, Event Handler, and Storage Sink - until the resulting entity is persisted, marking the end of the event’s modification to the system.</p>\\n\\n\\n\\n<p>Each query is much simpler as only the current system state is needed, which we’ve conveniently persisted alongside the corresponding event. The query request flows through a traditional service and repository implementation which ultimately leverages Kafka’s interactive query API to produce the latest system state.</p>\\n\\n\\n\\n<h2><strong>Conclusion</strong></h2>\\n\\n\\n\\n<p>This article has shown a complete working application for a Kafka-based event sourcing system that implements our simple banking account example. It has also shared several efficiency paradigms that are useful for real-world event sourcing applications, specifically derived state stores that provide easy access to the latest available state without needing to reprocess (“source”) all the stored events for each and every processing operation.</p>\\n\\n\\n\\n<p>Once you build and run the completed application, you will see log output indicating the sending and receiving of commands and events, together with the periodic output of the latest account balance.</p>\\n\\n\\n\\n<p>It is worth mentioning that this example is by no means canonical - it only shows one way of designing and building such a system. Hopefully, seeing a fully-working example like this can provide inspiration for implementing your own event sourcing system.</p>\\n\\n\\n\\n<p>If you need help architecting your next enterprise application or improving your current architecture, please <a href=\\\"https://www.sitepen.com/contact/\\\">contact us</a> to discuss how we can help!</p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Where We Left Off Previously In the previous architecture spotlight entry, we discussed Event Sourcing and illustrated the concept with a simple banking account example. We laid out many of its pros and cons to help readers decide if the pattern would be useful to them. In this post, we will be expanding the example [&hellip;]</p>\\n\",\"protected\":false},\"author\":98,\"featured_media\":26311,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[499,498,485,496],\"tags\":[],\"series\":[],\"jetpack_featured_media_url\":\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Architecture Spotlight: Event Sourcing, part two | SitePen</title>\\n<meta name=\\\"description\\\" content=\\\"How Kafka can be used to provide persistent messaging infrastructure and key/value data storage, supporting both event sequencing and a derived state storage.\\\" />\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Architecture Spotlight: Event Sourcing, part two | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"How Kafka can be used to provide persistent messaging infrastructure and key/value data storage, supporting both event sequencing and a derived state storage.\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2020-08-06T15:00:00+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-08-06T16:41:42+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"2400\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"1200\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-\\\\u2013-Event-Sourcing-Part-2@2x.png\\\",\\\"width\\\":2400,\\\"height\\\":1200,\\\"caption\\\":\\\"Event Sourcing\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/#webpage\\\",\\\"url\\\":\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/\\\",\\\"name\\\":\\\"Architecture Spotlight: Event Sourcing, part two | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/#primaryimage\\\"},\\\"datePublished\\\":\\\"2020-08-06T15:00:00+00:00\\\",\\\"dateModified\\\":\\\"2020-08-06T16:41:42+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/88cc1448e58fbc7e02ff6fc5d2ff3b8b\\\"},\\\"description\\\":\\\"How Kafka can be used to provide persistent messaging infrastructure and key/value data storage, supporting both event sequencing and a derived state storage.\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing-part-two/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/88cc1448e58fbc7e02ff6fc5d2ff3b8b\\\",\\\"name\\\":\\\"Stuart Bing\\\\u00eb\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Stuart Bing\\\\u00eb\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/24115\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/98\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=24115\"}],\"version-history\":[{\"count\":28,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/24115/revisions\"}],\"predecessor-version\":[{\"id\":26324,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/24115/revisions/26324\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/26311\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=24115\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=24115\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=24115\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=24115\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":98,\"name\":\"Stuart Bingë\",\"url\":\"\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/sbinge/\",\"slug\":\"sbinge\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Stuart Bingë, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Stuart Bingë, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/sbinge/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/sbinge/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/sbinge/\\\",\\\"name\\\":\\\"Stuart Bing\\\\u00eb, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/88cc1448e58fbc7e02ff6fc5d2ff3b8b\\\",\\\"name\\\":\\\"Stuart Bing\\\\u00eb\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/cce845a2444f62e04f5052e91c44a2c5?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Stuart Bing\\\\u00eb\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/sbinge/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/98\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"id\":26311,\"date\":\"2020-07-09T17:50:07\",\"slug\":\"blog-event-sourcing-part-22x\",\"type\":\"attachment\",\"link\":\"https://wp.sitepen.com/blog/architecture-spotlight-event-sourcing/blog-event-sourcing-part-22x/\",\"title\":{\"rendered\":\"Blog – Event Sourcing Part 2@2x\"},\"author\":103,\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Blog – Event Sourcing Part 2@2x | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Blog – Event Sourcing Part 2@2x | SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-08-06T14:56:19+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"2400\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"1200\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-\\\\u2013-Event-Sourcing-Part-2@2x.png#webpage\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-\\\\u2013-Event-Sourcing-Part-2@2x.png\\\",\\\"name\\\":\\\"Blog \\\\u2013 Event Sourcing Part 2@2x | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"datePublished\\\":\\\"2020-07-10T00:50:07+00:00\\\",\\\"dateModified\\\":\\\"2020-08-06T14:56:19+00:00\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-\\\\u2013-Event-Sourcing-Part-2@2x.png\\\"]}]}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"caption\":{\"rendered\":\"\"},\"alt_text\":\"Event Sourcing\",\"media_type\":\"image\",\"mime_type\":\"image/png\",\"media_details\":{\"width\":2400,\"height\":1200,\"file\":\"2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\",\"sizes\":{},\"image_meta\":{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\",\"keywords\":[]}},\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2020/04/Blog-–-Event-Sourcing-Part-2@2x.png\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/26311\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/attachment\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/103\"}]}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cache-control","max-age=2592000"],["connection","close"],["content-type","application/json; charset=UTF-8"],["date","Mon, 10 Aug 2020 15:29:15 GMT"],["expires","Wed, 09 Sep 2020 15:29:15 GMT"],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","Apache"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.21-1+0~20200807.66+debian9~1.gbp18a1c2"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}