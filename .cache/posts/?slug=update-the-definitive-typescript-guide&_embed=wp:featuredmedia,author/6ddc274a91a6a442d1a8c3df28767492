{"value":{"body":"[{\"id\":16368,\"date\":\"2020-04-10T09:30:26\",\"date_gmt\":\"2020-04-10T16:30:26\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=16368\"},\"modified\":\"2020-05-29T09:46:35\",\"modified_gmt\":\"2020-05-29T16:46:35\",\"slug\":\"update-the-definitive-typescript-guide\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/update-the-definitive-typescript-guide/\",\"title\":{\"rendered\":\"The Definitive TypeScript Guide\"},\"content\":{\"rendered\":\"<p><em>Originally published Oct 29, 2018. <strong>Updated May 29, 2020. </strong>This article describes the features and functionality of TypeScript 3.9. </em></p>\\n<p>One of the most interesting languages for large-scale application development is Microsoft&#8217;s <a href=\\\"https://typescriptlang.org\\\">TypeScript</a>. TypeScript is unique in that it is a superset of JavaScript, but with optional types, interfaces, generics, and more. Unlike other compile-to-JavaScript languages, TypeScript does not try to change JavaScript into a new language. Instead, the TypeScript team is careful to align the language&#8217;s extra features as closely as possible with what&#8217;s available in JavaScript, both current and draft features. Because of this, TypeScript developers are able to take advantage of the latest features in the JavaScript language in addition to a powerful type system to write better-organized code, all while taking advantage of the advanced tooling that using a statically typed language can provide.</p>\\n<p>Tooling support is where TypeScripts really shines. Modular code and static types allow for better structured projects that are easier to maintain. This is especially important as JavaScript projects grow in size (both in terms of lines of code and developers on the project). Having fast, accurate completion, refactoring capabilities, and immediate feedback makes TypeScript the ideal language for large-scale JavaScript.</p>\\n<p>Getting started with TypeScript is easy! Since vanilla JavaScript is effectively TypeScript without type annotations, much or all of an existing project can be used immediately and then updated over time to take advantage of all that TypeScript has to offer.</p>\\n<p>While TypeScript&#8217;s documentation has improved significantly since this guide was first posted, this Definitive Guide still provides one of the best overviews of the key features of TypeScript, assuming you already have a reasonable knowledge of JavaScript. The guide is regularly updated to provide new information about the latest versions of TypeScript.</p>\\n<p><strong>Installation and usage</strong></p>\\n<p>Installing TypeScript is as simple as running <code>npm install typescript</code>. Once installed, the TypeScript compiler is available by running <code>npx tsc</code>. If you want to try out TypeScript in your browser, the <a href=\\\"http://www.typescriptlang.org/Playground/\\\">TypeScript Playground</a> lets you experience TypeScript with a full code editor, with the limitation that modules cannot be used. Most of the examples in this guide can be pasted directly into the playground to quickly see how TypeScript compiles into easy-to-read JavaScript.</p>\\n<p>From the command line, the compiler can run in a couple of different modes, selectable with <a href=\\\"https://www.typescriptlang.org/docs/handbook/compiler-options.html#compiler-options\\\">compiler options</a>. Just calling the executable will build the current project. Calling with <code>--noEmit</code> will type check the project but won&#8217;t emit any code. Adding a <code>--watch</code> option will start a server process that will continually watch a project and incrementally rebuild it whenever a file is changed, which can be much faster than performing a full compile from scratch. An <code>--incremental</code> flag was added in TS 3.4 that lets the compiler save some compiler states to a file, making subsequent full compiles faster (although not as fast as a watch-based rebuild).</p>\\n<p><strong>Configuration</strong></p>\\n<p>The TypeScript compiler is highly configurable, allowing the user to define where source files are located, how they should be transpiled, whether standard JavaScript files should be processed, and how strict the type checker should be. A <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#using-tsconfigjson\\\">tsconfig.json</a></code> file identifies a project to the TypeScript compiler and contains settings used to build a TS project such as <a href=\\\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\\\">compiler flags</a>. Most of the configuration options can also be passed directly to the <code>tsc</code> command. This is the <code>tsconfig.json</code> from the <a href=\\\"https://dojo.io/\\\">Dojo</a> project&#8217;s <a href=\\\"https://github.com/dojo/framework\\\">framework</a> package:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n{\\r\\n  &quot;extends&quot;: &quot;./node_modules/@dojo/scripts/tsconfig/umd.json&quot;,\\r\\n  &quot;compilerOptions&quot;: {\\r\\n    &quot;jsx&quot;: &quot;react&quot;,\\r\\n    &quot;jsxFactory&quot;: &quot;tsx&quot;,\\r\\n    &quot;types&quot;: [ &quot;intern&quot; ],\\r\\n    &quot;lib&quot;: [\\r\\n      &quot;dom&quot;,\\r\\n      &quot;es5&quot;,\\r\\n      &quot;es2015.core&quot;,\\r\\n      &quot;es2015.iterable&quot;,\\r\\n      &quot;es2015.promise&quot;,\\r\\n      &quot;es2015.symbol&quot;,\\r\\n      &quot;es2015.symbol.wellknown&quot;,\\r\\n      &quot;es2015.proxy&quot;\\r\\n    ]\\r\\n  },\\r\\n  &quot;include&quot;: [\\r\\n    &quot;./src/**/*.ts&quot;,\\r\\n    &quot;./src/**/*.tsx&quot;,\\r\\n    &quot;./tests/**/*.ts&quot;,\\r\\n    &quot;./tests/**/*.tsx&quot;\\r\\n  ]\\r\\n}\\r\\n</pre>\\n<p>The <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#extends\\\">extends</a></code> property indicates that this file is extending another <code>tsconfig.js</code>on file; much like extending a class, the settings in the file being extended are used as defaults, and the settings in the file doing the extending are overrides. The <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#jsx\\\">jsx</a></code> property indicates that the project may use <a href=\\\"https://facebook.github.io/jsx/\\\">JSX</a> syntax, and that JSX should be transformed into React-style JavaScript. The <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#include\\\">include</a></code> option tells the compiler which files to include in the compilation.</p>\\n<p>TypeScript provides <a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig\\\">many options</a> to control how the compiler works, such as the ability to relax type checking strictness or to allow vanilla JavaScript files to be processed. This is one of the best parts of TypeScript: it allows TypeScript to be added to an existing project without requiring that the entire project be converted to fully-typed TypeScript. For example, the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#noImplicitAny\\\">noImplicitAny</a></code> flag, when <code>false</code>, will prevent the compiler from emitting warnings about untyped variables. Over time, a project can disable this and enable stricter processing options, allowing a team to work up, incrementally, towards fully-typed code. For new TypeScript projects, it is recommended that the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#strict\\\">strict</a></code> flag be enabled from the beginning to receive the full benefit of TypeScript.</p>\\n<p><strong>Syntax and JavaScript support</strong></p>\\n<p>TypeScript supports current JavaScript syntax (through ES2019), as well as a number of draft language proposals. In <em>most</em> cases, TypeScript can emit code that&#8217;s compatible with older JavaScript runtimes even when using new features, allowing developers to write code using modern JS features that can still run in legacy environments.</p>\\n<p>Proposed JavaScript features supported by TypeScript include:</p>\\n<ul>\\n<li><a href=\\\"https://tc39.es/proposal-class-fields/\\\">Class fields</a></li>\\n<li><a href=\\\"https://tc39.github.io/proposal-async-iteration/\\\">for-await-of loop iteration</a> <em>(TS 2.3, ES3/ES5 with </em><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#downlevelIteration\\\"><em>downlevelIteration</em></a><em>)</em></li>\\n<li><a href=\\\"https://tc39.github.io/proposal-dynamic-import/\\\">dynamic import expressions</a> <em>(TS 2.4)</em></li>\\n<li><a href=\\\"https://tc39.github.io/proposal-optional-catch-binding/\\\">optional catch clause variables</a> <em>(TS 2.5)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-numeric-separator/\\\">numeric separators</a> <em>(TS 2.7)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-import-meta/\\\">import.meta</a> <em>(TS 2.9)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-bigint/\\\">BigInt</a> <em>(TS 3.2)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-optional-chaining/\\\">Optional chaining</a> <em>(TS 3.7)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-nullish-coalescing/\\\">Nullish coalescing</a> <em>(TS 3.7)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-class-fields/\\\">ECMAScript Private fields</a> <em>(TS 3.8)</em></li>\\n<li><a href=\\\"https://tc39.es/proposal-top-level-await/\\\">Top-level await</a> <em>(TS 3.8)</em></li>\\n<li><a href=\\\"https://www.typescriptlang.org/docs/handbook/classes.html#ecmascript-private-fields\\\">Private class fields</a> <em>(TS 3.8, ES2020, only supported for ES2015+ targets)</em></li>\\n<li><em><a href=\\\"https://tc39.es/proposal-export-ns-from/\\\">export * as ns syntax</a></em> <em>(TS 3.8, ES2020)</em></li>\\n</ul>\\n<p>There&#8217;s more to JavaScript than just syntax, though. TS also needs to understand the types used by the JavaScript standard library, which has changed over time. By default, the TS compiler emits ES3 code and assumes an ES3-compatible standard library. So, for example, arrays won&#8217;t have an <code>include</code> method. Setting the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#target\\\">target</a></code> compiler option to &#8220;es2015&#8221; (or &#8220;ES2015&#8221;; most TS option values aren&#8217;t case-sensitive) will instruct the compiler to emit ES2015 code, and also causes it to load several built-in ES2015 type libraries, one of which includes typings for <code>Array.prototype.include</code>.</p>\\n<p>Note that these are <em>type</em> libraries, not polyfills. They tell the compiler what features arrays will have in the target environment, but do not actually provide any functionality themselves.</p>\\n<p>The <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#lib\\\">lib</a></code> config property allows specific type subsets to be enabled to tailor the compiler&#8217;s output for a particular environment. For example, if a project will be running in a legacy environment that&#8217;s known to have a polyfill for  <code>Array.prototype.include</code>, then &#8220;<code>es2016.array.include</code>&#8221; could be added to the <code>lib</code> property to let the compiler know that this method (but not other ES2016 library methods) will be available. If code will be running in a browser, then &#8220;dom&#8221; should be added to <code>lib</code> to tell the compiler that global DOM resources will be available.</p>\\n<p>Different support libraries may also be used in specific files rather than the entire project with another TypeScript feature: <a href=\\\"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-lib-\\\">triple slash directives</a>. These are single-line comments containing XML tags that specify compiler directives, such as the <code>lib</code> setting. For example:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n/// &lt;reference lib=&quot;es2016.array.include&quot; /&gt;\\r\\n\\r\\n[ 'foo', 'bar', 'baz' ].includes('bar'); // true\\r\\n</pre>\\n<p>The compiler will not throw an error about the use of <code>Array.prototype.includes</code> in the module containing the directive. However, if another file in the project tried to use <code>includes</code>, the compiler would throw an error. Note that not all compiler directives can be provided with triple slash directives, and also that these directives are only valid at the top of a TS file.</p>\\n<p>While TypeScript supports standard JavaScript syntax, it also adds some new syntax, such as type annotations, access modifiers (public, private), and support for generics. TS 3.4 added support for a new <a href=\\\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions\\\">const assertion</a> that can be used to declare values as deeply constant (unlike JavaScript&#8217;s <code>const</code>, which only declares a variable itself as unwritable). These differences are additive; they don&#8217;t replace normal JS syntax, but add new capabilities in a syntax-compatible fashion.</p>\\n<p><strong>Imports and exports</strong></p>\\n<p>TypeScript files use the <code>.ts</code> file extension, and each file typically represents a module, similar to <a href=\\\"https://www.sitepen.com/blog/2012/06/25/amd-the-definitive-source/\\\">AMD</a>, <a href=\\\"http://wiki.commonjs.org/wiki/Modules/1.1\\\">CommonJS</a>, and native <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\\\">JavaScript modules</a> (ESM) files. TypeScript uses a relaxed version of the JavaScript import API to import and export resources from modules:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">import myModule from './myModule';</pre>\\n<p>The main difference from standard ESM imports is that TypeScript doesn&#8217;t require absolute URLs and file extensions when referencing modules. It will assume a <code>.ts</code> or <code>.js</code> file extension, and uses a couple of different module resolution strategies to locate modules.</p>\\n<p>For AMD, SystemJS, and ES2015 modules, TypeScript defaults to its &#8220;classic&#8221; strategy. For any other module type it defaults to its &#8220;node&#8221; strategy. The strategy can be manually set with the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#moduleResolution\\\">moduleResolution</a></code> config option.</p>\\n<p>When the classic strategy is in use, relative module IDs are resolved relative to the directory containing the referencing module. For absolute module IDs, the compiler walks up the filesystem, starting from the directory containing the referencing module, looking for <code>.ts</code>, then <code>.d.ts</code>, in each parent directory, until it finds a match.</p>\\n<p>The node strategy uses Node&#8217;s module resolution logic. Relative module IDs are resolved relative to the directory containing the referencing module, and will consider the &#8220;main&#8221; field in a <code>package.json</code> if present. Absolute module IDs are resolved by first looking for the referenced module in a local <code>node_modules</code> directory, and then by walking up the directory hierarchy, looking for the module in <code>node_modules</code> directories.</p>\\n<p>In both strategies, the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#baseUrl\\\">baseUrl</a>,</code> <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#paths\\\">paths</a></code>, and <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#rootDirs\\\">rootDirs</a></code> options can be used to further configure where the compiler looks for absolutely-referenced modules.</p>\\n<p>TypeScript can emulate ESM&#8217;s default import semantics when working with legacy module formats like CommonJS. Enabling the <code><a href=\\\"https://www.typescriptlang.org/v2/en/tsconfig#esModuleInterop\\\">esModuleInterop</a></code> flag will make the compiler emit code allowing default imports to work for legacy modules that don&#8217;t technically have default exports.</p>\\n<p><strong>Basic types</strong></p>\\n<p>Types are the banner feature of TypeScript. The TS compiler determines a type for every value (variable, function argument, return value, etc.) in a program, and it uses these types for a range of features, from indicating when a function is being called with the wrong input to enabling an IDE to auto-complete a class property name.</p>\\n<p>Without additional type hints, all variables in TypeScript have the <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#any\\\">any</a></code> type, meaning they are allowed to contain any type of data, just like a JavaScript variable. The basic syntax for adding type constraints to code in TypeScript looks like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction toNumber(numberString: string): number {\\r\\n  const num: number = parseFloat(numberString);\\r\\n  return num;\\r\\n}\\r\\n</pre>\\n<p>The bolded type hints in the code above indicate that <code>toNumber</code> accepts one string parameter, and that it returns a number. The variable <code>num</code> is also explicitly typed to contain a number. Note that in many cases <strong>explicit type hints are not required</strong> (although it still may be beneficial to provide them) because TypeScript can <em>infer</em> them from the code itself. For example, the <code>number</code> type could be left off of the num declaration, because the TS compiler knows that <code>parseFloat</code> returns a number. Similarly, the number return type isn&#8217;t required because the compiler knows that the function always returns a number.</p>\\n<p>The primitive types that TypeScript provides match the primitive types of JavaScript itself: <code>any</code>, <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#number\\\">number</a></code>, <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#string\\\">string</a></code>, <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#boolean\\\">boolean</a></code>. TypeScript also has <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#void\\\">void</a></code> (for null or undefined function return values), <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#never\\\">never</a></code>, and as of TypeScript 3.0, <code><a href=\\\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\\\">unknown</a></code>.</p>\\n<p>In most cases, <code>never</code> is inferred for functions where the compiler detects unreachable code, so developers won&#8217;t often use <code>never</code> directly. For example, if a function only throws, it will have a return type of <code>never</code>.</p>\\n<p><code>unknown</code> is the type-safe counterpart of <code>any</code>; anything can be assigned to an unknown variable, but an unknown value can&#8217;t be assigned to anything other than an <code>any</code> variable without a type assertion or type narrowing.</p>\\n<p>When writing an expression (function call, arithmetic operation, etc.), you can also explicitly indicate the resulting type of the expression with a <a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions\\\">type assertion</a>, which is necessary if you are calling a function where TypeScript cannot figure out the return type automatically. For example:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction numberStringSwap(value: any, radix: number = 10): any {\\r\\n  if (typeof value === 'string') {\\r\\n    return parseInt(value, radix);\\r\\n  } else if (typeof value === 'number') {\\r\\n    return String(value);\\r\\n  }\\r\\n}   \\r\\n\\r\\nconst num = numberStringSwap('1234') as number;\\r\\nconst str = &lt;string&gt; numberStringSwap(1234);\\r\\n</pre>\\n<p>In this example, the return value of <code>numberStringSwap</code> has been declared as <code>any</code> because the function might return more than one type. In order to remove the ambiguity, the type of the expression being assigned to <code>num</code> is explicitly asserted by the <code>as number</code> modifier after the call to <code>numberStringSwap</code>.</p>\\n<p>Type assertions must be made to compatible types. If TypeScript knew that <code>numberStringSwap</code> returned a string on line 10, attempting to assert that the value was a number would result in a compiler error (&#8220;Cannot convert string to number&#8221;) since the two types are known to be incompatible.</p>\\n<p>There is also a legacy syntax for type-casting that uses angle brackets (&lt;&gt;), as shown in line 11 above. The semantics for using angle brackets is the same as for using <code>as</code>. This used to be the default syntax, but it was replaced by <code>as</code> due to conflicts with JSX syntax (more on that later).</p>\\n<p>When writing code in TypeScript, it is a good practice to explicitly add types to your variables and functions when types cannot be inferred, or when you want to ensure a certain type (such as a function return type), or just for documentation. When a variable is not annotated and the type cannot be inferred, it is given an implicit any type. The <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#noImplicitAny\\\">noImplicitAny</a></code> compiler option can be set in the <code>tsconfig.json</code> or on the command line and will prevent <code>any</code> accidental implicit any types from sneaking into your code.</p>\\n<p>TypeScript also has support for string literal types. These are useful when you know that the value of a parameter can match one of a list of strings, for example:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">let easing: &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;</pre>\\n<p>The compiler will check that any assignment to easing has one of the three values: <code>ease-in</code>, <code>ease-out</code>, or <code>ease-in-out</code>.</p>\\n<p><strong>Object types</strong></p>\\n<p>In addition to the primitive types, TypeScript allows complex types (like objects and functions) to be easily defined and used in type constraints. Just as object literals are at the root of most object definitions in JavaScript, the <em>object type literal</em> is at the root of most object type definitions in TypeScript. In its most basic form, it looks very similar to a normal JavaScript object literal:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet point: {\\r\\n  x: number;\\r\\n  y: number;\\r\\n};\\r\\n</pre>\\n<p>In this example, the <code>point</code> variable is defined as accepting any object with numeric <code>x</code> and <code>y</code> properties. Note that, unlike a normal object literal, the object type literal <strong>separates fields using semicolons</strong>, not commas.</p>\\n<p>TypeScript also includes an <code>object</code> type, which represents any non-primitive value (i.e., not a number, string, etc.). This type is distinct from <code>Object</code>, which can represent any JavaScript type (including primitives). For example, <code><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\\\">Object.create</a></code>&#8216;s first argument must be an object (a non-primitive) or null. If this argument is typed as an <code>Object</code>, TypeScript will allow primitive values to be passed to <code>Object.create</code>, which would cause a runtime error. When the argument is typed as an <code>object</code>, TypeScript will only allow non-primitive values to be used. The <code>object</code> type is also distinct from object type literals since it doesn&#8217;t specify any structure for an object.</p>\\n<p>When TypeScript compares two different object types to decide whether or not they match, it does so <em>structurally</em>. This means that instead of checking whether two values both inherit from a shared ancestor type, as typing checking in many other languages does, the compiler instead compares the properties of each object to see if they are compatible. If an object being assigned has all of the properties that are required by the constraint on the variable being assigned to, and the property types are compatible, then the two types are considered compatible:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet point: { x: number; y: number; };\\r\\n\\r\\n// OK, properties match\\r\\npoint = { x: 0, y: 0 };\\r\\n\\r\\n// Error, x property type is wrong\\r\\npoint = { x: 'zero', y: 0 };\\r\\n\\r\\n// Error, missing required property y\\r\\npoint = { x: 0 };\\r\\n\\r\\n// Error, object literal may only specify known properties\\r\\npoint = { x: 0, y: 0, z: 0 };\\r\\n\\r\\nconst otherPoint = { x: 0, y: 0, z: 0 };\\r\\n\\r\\n// OK, extra properties not relevant for non-literal assignment\\r\\npoint = otherPoint;\\r\\n</pre>\\n<p>Note the error when assigning a literal object with an extra property.  Literal values are checked more strictly than non-literals.</p>\\n<p>In order to reduce type duplication, the <code>typeof</code> operator can be used to reference the type of a value. For instance, if we were to add a <code>point2</code> variable, instead of having to write this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet point: { x: number; y: number; };\\r\\nlet point2: { x: number; y: number; };\\r\\n</pre>\\n<p>We could instead simply reference the type of <code>point</code> using <code>typeof</code>:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet point: { x: number; y: number; };\\r\\nlet point2: typeof point;\\r\\n</pre>\\n<p>This mechanism helps to reduce the amount of code we need to reference the same type, but there is another even more powerful abstraction in TypeScript for reusing object types: <em>interfaces</em>. An interface is, in essence, a <strong>named</strong> object type literal. Changing the previous example to use an interface would look like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  x: number;\\r\\n  y: number;\\r\\n}\\r\\n\\r\\nlet point: Point;\\r\\nlet point2: Point;\\r\\n</pre>\\n<p>This change allows the <code>Point</code> type to be used in multiple places within the code without having to redefine the type&#8217;s details over and over again. Interfaces can also extend other interfaces or classes using the <code>extends</code> keyword in order to compose more complex types out of simple types:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point3d extends Point {\\r\\n  z: number;\\r\\n}\\r\\n</pre>\\n<p>In this example, the resulting <code>Point3d</code> type would consist of the <code>x</code> and <code>y</code> properties of the <code>Point</code> interface, plus the new <code>z</code> property.</p>\\n<p>Methods and properties on objects can also be specified as optional, in the same way that function parameters can be made optional:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  x: number;\\r\\n  y: number;\\r\\n  z?: number;\\r\\n}\\r\\n</pre>\\n<p>Here, instead of specifying a separate interface for a three-dimensional point, we simply make the <code>z</code> property of the interface optional; the resulting type checking would look like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet point: Point;\\r\\n\\r\\n// OK, properties match\\r\\npoint = { x: 0, y: 0, z: 0 };\\r\\n\\r\\n// OK, properties match, optional property missing\\r\\npoint = { x: 0, y: 0 };\\r\\n\\r\\n// Error, `z` property type is wrong\\r\\npoint = { x: 0, y: 0, z: 'zero' };\\r\\n</pre>\\n<p>So far, we&#8217;ve looked at object types with properties, but haven&#8217;t specified how to add a <strong>method</strong> to an object. Because functions are first-class objects in JavaScript, they can be typed like any other object property (we&#8217;ll talk more about functions later):</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  x: number;\\r\\n  y: number;\\r\\n  z?: number;\\r\\n\\r\\n  toGeo: () =&gt; Point;\\r\\n}\\r\\n</pre>\\n<p>Here we&#8217;ve declared a <code>toGeo</code> property on <code>Point</code> with the type <code>() =&gt; Point</code> (a function that takes no arguments and returns a <code>Point</code>). TypeScript also provides a shorthand syntax for specifying methods, which becomes very convenient later when we start working with <a href=\\\"https://www.sitepen.com/blog/#classes\\\">classes</a>:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  x: number;\\r\\n  y: number;\\r\\n  z?: number;\\r\\n\\r\\n  toGeo(): Point;\\r\\n}\\r\\n</pre>\\n<p>Like properties, methods can also be made optional by putting a question mark after the method name:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  // ...\\r\\n  toGeo?(): Point;\\r\\n}\\r\\n</pre>\\n<p>Objects that are intended to be used as hash maps or ordered lists can be given an <a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types-and-index-signatures\\\">index signature</a>, which enables arbitrary keys to be defined on an object:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface HashMapOfPoints {\\r\\n  [key: string]: Point;\\r\\n}\\r\\n</pre>\\n<p>In this example, we&#8217;ve defined a type where arbitrary string keys can be set, so long as the assigned value is of type <code>Point</code>. As in JavaScript, it is only possible to use <code>string</code> or <code>number</code> as the type of the index signature.</p>\\n<p>For object types without an index signature, TypeScript will only allow properties to be set that are explicitly defined on the type. If you try to assign to a property that doesn&#8217;t exist on the type, you will get a compiler error. Occasionally, though, you <strong>do</strong> want to add dynamic properties to an object without an index signature. To do so, you can simply use array notation to set the property on the object: <code>a['foo'] = 'foo'</code>. Note, however, that using this workaround defeats the type system for these properties, so only do this as a last resort.</p>\\n<p>Interface properties can also be named using constant values, similar to computed property names on normal objects. Computed values must be constant strings, numbers, or Symbols:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nconst Foo = 'Foo';\\r\\nconst Bar = 'Bar';\\r\\nconst Baz = Symbol();\\r\\n\\r\\ninterface MyInterface {\\r\\n  [Foo]: number;\\r\\n  [Bar]: string;\\r\\n  [Baz]: boolean;\\r\\n}\\r\\n</pre>\\n<p><strong>Tuple types</strong></p>\\n<p>While JavaScript itself doesn&#8217;t have <a href=\\\"https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple\\\">tuples</a>, TypeScript makes it possible to emulate typed tuples using arrays. If you wanted to store a point as an <code>(x, y, z)</code> tuple instead of as an object, this can be done by specifying a tuple type on a variable:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">let point: [ number, number, number ] = [ 0, 0, 0 ];</pre>\\n<p>TypeScript 3.0 improved support for tuple types by allowing them to be used with rest and spread expressions, and by allowing for optional elements.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction draw(...point: [ number, number, number? ]): void {\\r\\n  const [ x, y, z ] = point;\\r\\n  console.log('point', ...point);\\r\\n}\\r\\n\\r\\ndraw(100, 200);         // logs: point 100, 200\\r\\ndraw(100, 200, 75);     // logs: point 100, 200, 75\\r\\ndraw(100, 200, 75, 25); // Error: Expected 2-3 arguments but got 4\\r\\n</pre>\\n<p>In the above example, the <code>draw</code> function can accept values for <code>x, y,</code> and optionally <code>z</code>. Tuple types have had a fixed length since TypeScript 2.7, but values within the tuple may be marked as optional.</p>\\n<p><strong>Function types</strong></p>\\n<p>Function types are typically defined using arrow syntax:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">let printPoint: (point: Point) =&amp;gt; string;</pre>\\n<p>Here the variable printPoint is described as accepting a function that takes a Point argument and returns a string. The same syntax is used to describe a function argument to another function:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">let printPoint: (getPoint: () =&amp;gt; Point) =&amp;gt; string;</pre>\\n<p>Note the use of the arrow (<code>=&gt;</code>) to define the return type of the function. This differs from how the return type is written in a function declaration, where a colon (:) is used:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction printPoint(point: Point): string { ... }\\r\\nconst printPoint = (point: Point): string =&amp;gt; { ... }\\r\\n[/ode]\\r\\n\\r\\nThis can be a bit confusing at first, but as you work with TypeScript, you will find it is easy to know when one or the other should be used. For instance, in the original &lt;code&gt;printPoint&lt;/code&gt; example, using a colon would &lt;em&gt;look&lt;/em&gt; wrong because it would result in two colons directly within the constraint:\\r\\n\\r\\nlet printPoint: (point: Point): string</pre>\\n<p>Similarly, using an arrow with an arrow function would look wrong:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">const printPoint = (point: Point) =&amp;gt; string =&amp;gt; { ... }</pre>\\n<p>Functions can also be described using the object literal syntax:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">let printPoint: { (point: Point): string; };</pre>\\n<p>This is effectively describing <code>printPoint</code> as a callable object (which is what a JavaScript function is).</p>\\n<p>Functions can be typed as constructors by putting the <code>new</code> keyword before the function type:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet Point: { new (): Point; };\\r\\nlet Point: new () =&amp;gt; Point;\\r\\n</pre>\\n<p>In this example, any function assigned to <code>Point</code> would need to be a constructor that creates <code>Point</code> objects.</p>\\n<p>Because the object literal syntax allows us to define objects as functions, it's also possible to define function types with static properties or methods (like the JavaScript <code>String</code> function, which also has a static method <code>String.fromCharCode</code>):</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet Point: {\\r\\n  new (): Point;\\r\\n  fromLinear(point: Point): Point;\\r\\n  fromGeo(point: Point): Point;\\r\\n};\\r\\n</pre>\\n<p>Here, we've defined <code>Point</code> as a constructor that also needs to have static <code>Point.fromLinear</code> and <code>Point.fromGeo</code> methods. The only way to actually do this is to define a <a href=\\\"https://www.sitepen.com/blog/#classes\\\">class</a> that implements <code>Point</code> and has static <code>fromLinear</code> and <code>fromGeo</code> methods; we'll look at how to do this later when we discuss classes in depth.</p>\\n<p>As of TypeScript 3.1, static fields may also be added to functions simply by assigning to them:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction createPoint(x: number, y: number) {\\r\\n  return new Point(x, y);\\r\\n}\\r\\n\\r\\ncreatePoint.print(point: Point): string {\\r\\n  // print a point\\r\\n}\\r\\n\\r\\nPoint p = createPoint(1, 2);\\r\\n\\r\\ncreatePoint.print(p); // prints the point\\r\\n</pre>\\n<p><strong>Overloaded functions</strong></p>\\n<p>Earlier, we created an example <code>numberStringSwap</code> function that converts between numbers and strings:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction numberStringSwap(value: any, radix: number): any {\\r\\n  if (typeof value === 'string') {\\r\\n    return parseInt(value, radix);\\r\\n  } else if (typeof value === 'number') {\\r\\n    return String(value);\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>We know that this function returns a string when it is passed a number, and a number when it is passed a string. However, the call signature doesn't indicate this -- since <code>any</code> is used for the value and return types, TypeScript doesn't know what specific types of values are acceptable or what type will be returned. We can use <em>function overloads</em> to let the compiler know more about how the function actually works.</p>\\n<p>One way to write the above function, in which typing is correctly handled, is:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction numberStringSwap(value: number, radix?: number): string;\\r\\nfunction numberStringSwap(value: string): number;\\r\\nfunction numberStringSwap(value: any, radix: number = 10): any {\\r\\n  if (typeof value === 'string') {\\r\\n    return parseInt(value, radix);\\r\\n  } else if (typeof value === 'number') {\\r\\n    return String(value);\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>With the above types, TypeScript now knows that the function can be called in two ways: with a number and optional radix, or with a string. If it's called with a number, it will return a string, and vice versa. You can also use <a href=\\\"https://www.sitepen.com/blog/#union-types\\\">union types</a> in some cases instead of function overloads, which will be discussed later in this guide.</p>\\n<p>It is extremely important to keep in mind that the concrete function implementation must have an interface that matches the lowest common denominator of all of the overload signatures. This means that if a parameter accepts multiple types, as <code>value</code> does here, the concrete implementation must specify a type that encompasses <strong>all</strong> the possible options. In the case of <code>numberStringSwap</code>, because <code>string</code> and <code>number</code> have no common base, the type for <code>value</code> <em>must</em> be <code>any</code> (or a union type).</p>\\n<p>Similarly, if different overloads accept different numbers of arguments, <strong>any arguments that do not exist in all overload signatures must be optional</strong> in the concrete implementation. For <code>numberStringSwap</code>, this means that we have to make the <code>radix</code> argument optional in the concrete implementation. This was done by specifying a default value for <code>radix</code>.</p>\\n<p>Not following these rules will result in a generic \\\"Overload signature is not compatible with function definition\\\" error.</p>\\n<p>Note that even though our fully defined function uses the <code>any</code> type for <code>value</code>, attempting to pass another type (like a boolean) for this parameter will cause TypeScript to throw an error because <strong>only the overloaded signatures are used for type checking</strong>. In a case where more than one signature would match a given call, the <em>first</em> overload listed in the source code will win:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction numberStringSwap(value: any): any;\\r\\nfunction numberStringSwap(value: number): string;\\r\\n\\r\\nnumberStringSwap('1234');\\r\\n</pre>\\n<p>Here, even though the second overload signature is more specific, the first will be used. This means that you always need to make sure your source code is ordered so more specific overloads won't be shadowed by more general ones.</p>\\n<p>Function overloads also work within object type literals, interfaces, and classes:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nlet numberStringSwap: {\\r\\n  (value: number, radix?: number): string;\\r\\n  (value: string): number;\\r\\n};\\r\\n</pre>\\n<p>Note that because we are defining a type and not creating an actual function declaration, the concrete implementation of numberStringSwap is omitted.</p>\\n<p>TypeScript also allows you to specify different return types when an exact string is provided as an argument to a function. For example, the DOM <code><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\\\">createElement</a></code> method could be typed like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ncreateElement(tagName: 'a'): HTMLAnchorElement;\\r\\ncreateElement(tagName: 'abbr'): HTMLElement;\\r\\ncreateElement(tagName: 'address'): HTMLElement;\\r\\ncreateElement(tagName: 'area'): HTMLAreaElement;\\r\\n// ... etc.\\r\\ncreateElement(tagName: string): HTMLElement;\\r\\n</pre>\\n<p>This would let TypeScript know that when, say <code>createElement('video')</code> is called, the return value will be an <code>HTMLVideoElement</code>, whereas when <code>createElement('a')</code> is called, the return value will be an <code>HTMLAnchorElement</code>.</p>\\n<p><strong>Strict function types</strong></p>\\n<p>By default, TypeScript is a bit lax when checking function type parameters. Consider the following example:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Animal { breathe() { } }\\r\\nclass Dog extends Animal { bark() {} }\\r\\nclass Cat extends Animal { meow() {} }\\r\\n   \\r\\nlet f1: (x: Animal) =&gt; void = (x: Animal) =&gt; x.breathe();\\r\\nlet f2: (x: Dog) =&gt; void = (x: Dog) =&gt; x.bark();\\r\\nlet f3: (x: Cat) =&gt; void = (x: Cat) =&gt; x.meow();\\r\\n   \\r\\nf1 = f2;\\r\\nconst c = new Cat();\\r\\nf1(c); // Runtime error\\r\\n</pre>\\n<p>Dog is a type of animal, so the assignment <code>f1 = f2</code> is valid. However, now <code>f1</code> is a function that can only accept <code>Dogs</code>, even though its type says it can accept any <code>Animal</code>. Trying to call <code>f1</code> on a <code>Cat</code> will generate a runtime error when the function tries to call <code>bark</code> on it.</p>\\n<p>TypeScript allows this situation because function arguments in TypeScript are <a href=\\\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant\\\">bivariant</a>, which is unsound (as far as typing is concerned). The <code>strictFunctionTypes</code> compiler option can be enabled to flag this kind of unsound assignment.</p>\\n<p><strong>Generic types</strong></p>\\n<p>TypeScript includes the concept of a <a href=\\\"https://en.wikipedia.org/wiki/Generic_programming\\\">generic type</a>, which can be roughly thought of as a type that must include or reference another type in order to be complete. Two generic types that you've probably already used are <code>Array</code> and <code>Promise</code>.</p>\\n<p>The syntax of a generic value type is <code>GenericType&lt;SpecificType&gt;</code>. For example, an \\\"array of strings\\\" type would be <code>Array&lt;string&gt;</code>, and a \\\"promise that resolves to a number\\\" type would be <code>Promise&lt;number&gt;</code>. Generic types may require more than one specific type, like <code>Converter&lt;TInput, TOutput&gt;</code>, but this is uncommon. The placeholder types inside the angle brackets are called <em>type parameters</em>.</p>\\n<p>To explain how to create your own generic types, consider how an Array-like class might be typed:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Arrayish&lt;T&gt; {\\r\\n  map&lt;U&gt;(\\r\\n    callback: (value: T, index: number, array: Arrayish&lt;T&gt;) =&gt; U,\\r\\n    thisArg?: any\\r\\n  ): Array&lt;U&gt;;\\r\\n}\\r\\n</pre>\\n<p>In this example, <code>Arrayish</code> is defined as a generic type with a single map method, which corresponds to the <code>Array#map</code> method from ECMAScript 5. The <code>map</code> method has a type parameter of its own, <code>U</code>, which is used to indicate that the return type of the callback function needs to be the same as the return type of the <code>map</code> call.</p>\\n<p>Actually using this type would look something like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nconst arrayOfStrings: Arrayish&lt;string&gt; = [ 'a', 'b', 'c' ];\\r\\nconst arrayOfCharCodes: Arrayish&lt;number&gt; =\\r\\n  arrayOfStrings.map(value =&gt; value.charCodeAt(0));\\r\\n</pre>\\n<p>Here, <code>arrayOfStrings</code> is defined as being an <code>Arrayish</code> containing strings, and <code>arrayOfCharCodes</code> is defined as being an <code>Arrayish</code> containing numbers. We call <code>map</code> on the array of strings, passing a callback function that returns numbers. If the callback returned a string instead of a number, the compiler would raise an error that the types were not compatible, because <code>arrayOfCharCodes</code> is explicitly typed.</p>\\n<p>Because arrays are an exceptionally common generic type, TypeScript provides a shorthand notation: <code>SpecificType[]</code>. Note, however, ambiguity can occasionally arise when using this shorthand. For example, is the type <code>() =&gt; boolean[]</code> an array of functions that return booleans, or is it a single function that returns an array of booleans? The answer is the latter; to represent the former, you would typically write <code>(() =&gt; boolean)[]</code>.</p>\\n<p>TypeScript also allows type parameters to be constrained to a specific type by using the <code>extends</code> keyword within the type parameter, like interface <code>PointPromise</code>. In this case, only a type that structurally matched <code>Point</code> could be used for <code>T</code>; trying to use something else, like <code>string</code>, would cause a type error.</p>\\n<p>Generic types may be given defaults, which can reduce boilerplate in many instances. For example, if we wanted a function that created an <code>Arrayish</code> based on the arguments passed but defaulted to <code>string</code> when no arguments are passed, we would write:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction createArrayish(...args: T[]): Arrayish {\\r\\n  return args;\\r\\n}\\r\\n</pre>\\n<p><strong>Union types</strong></p>\\n<p><a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types\\\">Union types</a> allow a parameter or variable to support more than one type. For example, if you wanted to have a convenience function like <code>document.getElementById</code> that could accept either a string ID or an element, like Dojo's byId function, you could do this using a union type:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction byId(element: string | Element): Element {\\r\\n  if (typeof element === 'string') {\\r\\n    return document.getElementById(element);\\r\\n  } else {\\r\\n    return element;\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>TypeScript is intelligent enough to contextually type the <code>element</code> variable inside the <code>if</code> block to be of type <code>string</code>, and to be of type <code>Element</code> in the <code>else</code> block. Code used to narrow types is referred to as a <a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\\\">type guard</a>; these will be discussed in more detail later in this article.</p>\\n<p><strong>Intersection types</strong></p>\\n<p>While union types indicate that a value may be one type or another, <a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types\\\">intersection types</a> indicate that a value will be a combination of multiple types; it must meet the contract of <strong>all</strong> of the member types. For example:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Foo {\\r\\n  name: string;\\r\\n  count: number;\\r\\n}\\r\\n\\r\\ninterface Bar {\\r\\n  name: string;\\r\\n  age: number;\\r\\n}\\r\\n\\r\\nexport type FooBar = Foo &amp; Bar;\\r\\n</pre>\\n<p>A value of type FooBar must have <code>name</code>, <code>count</code>, and <code>age</code> properties.</p>\\n<p>TypeScript doesn't require overlapping properties to have compatible types, so it's possible to make unusable types:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Foo {\\r\\n  count: string;\\r\\n}\\r\\n\\r\\ninterface Bar {\\r\\n  count: number;\\r\\n}\\r\\n\\r\\nexport type FooBar2 = Foo &amp; Bar;\\r\\n</pre>\\n<p>The <code>count</code> property in <code>FooBar2</code> is of type <code>never</code> since a value can't be both a string and a number, meaning no value can be assigned to it.</p>\\n<p><strong>Type aliases</strong></p>\\n<p>We saw earlier that <code>typeof</code> and <code>interfaces</code> were two ways to avoid having to code the full type of a value everywhere it's needed. Another way to accomplish this is with <a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases\\\">type aliases</a>. A type alias is just a reference to a specific type.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nimport * as foo from './foo';\\r\\ntype Foo = foo.Foo;\\r\\ntype Bar = () =&gt; string;\\r\\ntype StringOrNumber = string | number;\\r\\ntype PromiseOrValue&lt;T&gt; = T | Promise&lt;T&gt;;\\r\\ntype BarkingAnimal = Animal &amp; { bark(): void };\\r\\n</pre>\\n<p>Type aliases are very similar to interfaces. They can be extended using the intersection operator, as with the <code>BarkingAnimal</code> type shown above. They can also be used as the base type for interfaces (except for aliases to union types).</p>\\n<p>Unlike interfaces, aliases aren't subject to <a href=\\\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces\\\">declaration merging</a>. When an interface is defined multiple times in a single scope, the declarations will be merged into a single interface. A type alias, on the other hand, is a named entity, like a variable. As with variables, <strong>type declarations are block scoped</strong>, and you can't declare two types with the same name in the same scope.</p>\\n<p><strong>Mapped types</strong></p>\\n<p>Mapped types allow for the creation of new types based on existing types by mapping properties of an existing type to a new type. Consider the type <code>Stringify</code> below; <code>Stringify</code> will have all the same properties as T, but those properties will all have values of type string.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ntype Stringify&lt;T&gt; = {\\r\\n  [P in keyof T]: string;\\r\\n};\\r\\n\\r\\ninterface Point { x: number; y: number; }\\r\\ntype StringPoint = Stringify&lt;Point&gt;;\\r\\nconst pointA: StringPoint = { x: '4', Y: '3' }; // valid\\r\\n</pre>\\n<p>Note that mapped types only affect <em>types</em>, not values; the <code>Stringify</code> type above won't actually transform an object of arbitrary values into an object of strings.</p>\\n<p>TypeScript 2.8 added the ability to add or remove <code>readonly</code> or <code>?</code> modifiers from mapped properties. This is done using + and - to indicate whether the modifier should be added or removed.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ntype MutableRequired&lt;T&gt; = { -readonly [P in keyof T]-?: T[P] };\\r\\ntype ReadonlyPartial&lt;T&gt; = { +readonly [P in keyof T]+?: T[P] };\\r\\n   \\r\\ninterface Point { readonly x: number; y: number; }\\r\\nconst pointA: ReadonlyPartial&lt;Point&gt; = { x: 4 };\\r\\npointA.y = 3; // Error: readonly\\r\\nconst pointB: MutableRequired&lt;Point&gt; = { x: 4, y: 3 };\\r\\npointB.x = 2; // valid\\r\\n</pre>\\n<p>In the example above, <code>MutableRequired</code> makes all properties of its source type non-optional and writable, whereas <code>ReadonlyPartial</code> makes all properties optional and readonly.</p>\\n<p>TypeScript 3.1 introduced the ability to map over a tuple type and return a new tuple type. Consider the following example where a tuple type <code>Point</code> is defined. Suppose that in some cases points will actually be Promises that resolve to <code>Point</code> objects. TypeScript allows for the creation of the latter type from the former:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ntype ToPromise&lt;T&gt; = { [K in typeof T]: Promise&lt;T[K]&gt; };\\r\\ntype Point = [ number, number ];\\r\\ntype PromisePoint = ToPromise&lt;Point&gt;;\\r\\nconst point: PromisePoint =\\r\\n  [ Promise.resolve(2), Promise.resolve(3) ]; // valid\\r\\n</pre>\\n<p>Certain mapped type patterns are so common that they've become built-in types in TypeScript:</p>\\n<ul>\\n<li style=\\\"font-weight: 400;\\\"><a href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt\\\"><span style=\\\"font-weight: 400;\\\">Partial&lt;T&gt;</span></a><span style=\\\"font-weight: 400;\\\"> - constructs a type with all the properties of </span><span style=\\\"font-weight: 400;\\\">T</span><span style=\\\"font-weight: 400;\\\"> set to optional</span></li>\\n<li style=\\\"font-weight: 400;\\\"><a href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredt\\\"><span style=\\\"font-weight: 400;\\\">Required&lt;T&gt;</span></a><span style=\\\"font-weight: 400;\\\"> - constructs a type with all the properties of </span><span style=\\\"font-weight: 400;\\\">T</span><span style=\\\"font-weight: 400;\\\"> set to required</span></li>\\n<li style=\\\"font-weight: 400;\\\"><a href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlyt\\\"><span style=\\\"font-weight: 400;\\\">Readonly&lt;T&gt;</span></a><span style=\\\"font-weight: 400;\\\"> - constructs a type with all the properties of </span><span style=\\\"font-weight: 400;\\\">T</span><span style=\\\"font-weight: 400;\\\"> set to readonly</span></li>\\n<li style=\\\"font-weight: 400;\\\"><a href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkt\\\"><span style=\\\"font-weight: 400;\\\">Record&lt;K, T&gt;</span></a><span style=\\\"font-weight: 400;\\\"> - constructs a type with property names from </span><span style=\\\"font-weight: 400;\\\">K</span><span style=\\\"font-weight: 400;\\\">, where each property has type </span><span style=\\\"font-weight: 400;\\\">T</span></li>\\n<li style=\\\"font-weight: 400;\\\"><a href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#picktk\\\"><span style=\\\"font-weight: 400;\\\">Pick&lt;T, K&gt;</span></a><span style=\\\"font-weight: 400;\\\"> - constructs a type with just the properties from </span><span style=\\\"font-weight: 400;\\\">T</span><span style=\\\"font-weight: 400;\\\"> specified by </span><span style=\\\"font-weight: 400;\\\">K</span></li>\\n<li style=\\\"font-weight: 400;\\\"><a style=\\\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;\\\" href=\\\"https://www.typescriptlang.org/docs/handbook/utility-types.html#omittk\\\">Omit&lt;T, K&gt;</a><span style=\\\"font-weight: 400;\\\"> - constructs a type with all the properties from </span><span style=\\\"font-weight: 400;\\\">T</span> <i style=\\\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;\\\">except</i><span style=\\\"font-weight: 400;\\\"> those specified by </span><span style=\\\"font-weight: 400;\\\">K</span></li>\\n</ul>\\n<p><strong>Conditional types</strong></p>\\n<p><a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types\\\">Conditional types</a> allow for a type to be set dynamically based on a provided condition. All conditional types follow the same format: <code>T extends U ? X : Y</code>. This may look familiar since it uses the same syntax as a JavaScript <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\\\">ternary</a> statement. What this statement means is that if <code>T</code> is assignable to <code>U</code>, then set the type to <code>X</code>. Otherwise, set the type to <code>Y</code>.</p>\\n<p>This may seem like a very simple concept, but it can dramatically simplify complex typings. Consider the following example where we would like to define types for a function that accepts either a number or a string.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">declare function addOrConcat(x: number | string): number | string;</pre>\\n<p>The types here are fine but they do not truly convey the meaning or intent of the code. Presumably, if the argument is a <code>number</code> then the return type will also be <code>number</code>, and likewise with <code>string</code>. To correct this, we can use function overloading</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndeclare function addOrConcat(x: string): string;\\r\\ndeclare function addOrConcat(x: number): number;\\r\\ndeclare function addOrConcat(x: number | string): number | string;\\r\\n</pre>\\n<p>However this is a little verbose and can be tedious to change in the future. Enter conditional types!</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">declare function addOrConcat&amp;lt;T extends number | string&amp;gt;(x: T): T extends number ? number : string;</pre>\\n<p>This function signature is generic, stating that T will either be a <code>number</code> or a <code>string</code>. A conditional type is used to determine the return type; if the function argument is a <code>number</code>, the function return type is number, otherwise it's <code>string</code>.</p>\\n<p><strong>Type guards</strong></p>\\n<p><a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\\\">Type guards</a> allow for narrowing of types within a conditional block. This is essential when working with types that could be unions of two or more types, or where the type is not known until runtime. To do this in a way that is also compatible with the JavaScript code that will be run at runtime, the type system ties into the <code>typeof, instanceof</code>, and in (as of TS 2.7) operators. Inside of a conditional block using one of these checks, it is guaranteed that the value checked is of the specified type, and methods that would exist on that type can be used safely.</p>\\n<p><strong><code>typeof</code></strong><strong> and </strong><strong><code>instanceof</code></strong></p>\\n<p>TypeScript will use the JavaScript <code>typeof</code> and <code>instanceof</code> operators as type guards.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction lower(x: string | string[]) {\\r\\n  if (typeof x === 'string') {\\r\\n  // x is guaranteed to be a string, so we can use toLowerCase\\r\\n\\r\\n  return x.toLowerCase();\\r\\n} else {\\r\\n  // x is definitely an array of strings, so we can use reduce\\r\\n  return x.reduce(\\r\\n      (val: string, next: string) =&amp;gt; val += `, ${next.toLowerCase()}`, '');\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction clearElement(element: string | HTMLElement) {\\r\\n  if (element instanceof HTMLElement) {\\r\\n    // element is guaranteed to be an HTMLElement in here\\r\\n    // so we can access its innerHTML property\\r\\n    element.innerHTML = '';\\r\\n  } else {\\r\\n    // element is a string in here so we can pass that to querySelector\\r\\n    const el = document.querySelector(element);\\r\\n    el &amp;&amp; el.innerHTML = '';\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>TypeScript understands, based on the result of a <code>typeof</code> or <code>instanceof</code> check, what the type of <code>x</code> must be in each part of an <code>if/else</code> statement.</p>\\n<p><strong><code>in</code></strong></p>\\n<p>This type guard narrows the type within a conditional by checking if a property exists on the variable. If the result is <code>true</code>, the variable type will be narrowed to match the type that contains the value checked on.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Point {\\r\\n  x: number;\\r\\n  y: number;\\r\\n}\\r\\n\\r\\ninterface Point3d extends Point {\\r\\n  z: number;\\r\\n}\\r\\n\\r\\nfunction plot(point: Point) {\\r\\n  if ('z' in point) {\\r\\n    // point is a Point3D\\r\\n  } else {\\r\\n    // point is a Point\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p><strong>Type predicates</strong></p>\\n<p>You can also create functions that return <a href=\\\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates\\\">type predicates</a>, explicitly indicating the type of a value.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction isDog(animal: Animal): animal is Dog {\\r\\n  return typeof (animal as Dog).bark === 'function';\\r\\n}\\r\\n\\r\\nif (isDog(someAnimal)) {\\r\\n  someAnimal.bark(); // valid\\r\\n}\\r\\n</pre>\\n<p>The predicate <code>animal</code> is <code>Dog</code> says that if the function returns true, then the function's argument is explicitly of type <code>Dog</code>.</p>\\n<p><strong>Classes</strong></p>\\n<p>For the most part, classes in TypeScript are similar to classes in standard JavaScript, but there are a few differences to allow classes to be properly typed.</p>\\n<p>TypeScript allows class fields to be explicitly declared so that the compiler will know what properties are valid for a class. Class fields can also be declared as <code>protected</code> and <code>private</code>, and as of TS 3.8 may also use <a href=\\\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#-ecmascript-private-fields\\\">ECMAScript private fields</a>.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Animal {\\r\\n  protected _happy: boolean;\\r\\n  name: string;\\r\\n  #secretId: number;\\r\\n    \\r\\n  constructor(name: string) {\\r\\n    this.name = name;\\r\\n    this.#secretId = Math.random();\\r\\n  }\\r\\n\\r\\n  pet(): void {\\r\\n    this._happy = true;\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>Note that TypeScript's <code>private</code> modifier is not related to ECMAScript private fields, which are denoted with a hash sign (e.g., <code>#privateField</code>). Private TS fields are only private during compilation; at runtime they are accessible just like any normal class field. This is why the JavaScript convention of prefixing private fields with underscores is still commonly seen in TS code. ECMAScript private fields, on the other hand, have \\\"hard\\\" privacy, and are completely inaccessible outside of a class at runtime.</p>\\n<p>TypeScript also allows class fields to use a <code>static</code> modifier, which indicates that they are actually properties on the class itself rather than instance properties (on the class's prototype).</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Dog extends Animal {\\r\\n  static isDogLike(object: any): object is Dog {\\r\\n    return object.bark &amp;&amp; object.pet;\\r\\n  }\\r\\n}\\r\\n\\r\\nif (Dog.isDogLike(someAnimal)) {\\r\\n  someAnimal.bark();\\r\\n}\\r\\n</pre>\\n<p>Properties may be declared <code>readonly</code> to indicate that they can only be set when an object is created. This is essentially <code>const</code> for object properties.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Dog extends Animal {\\r\\n  readonly breed: string;\\r\\n    \\r\\n  constructor(name: string, breed: string) {\\r\\n    super(name);\\r\\n    this.breed = breed;\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>Properties may also be initialized in a class definition. The initial value of a property can be <strong>any assignment expression</strong>, not just a static value, and will be executed every time a new instance is created:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass DomesticatedDog extends Dog {\\r\\n  age = Math.random() * 20;\\r\\n  collarType = 'leather';\\r\\n  toys: Toy[] = [];\\r\\n}\\r\\n</pre>\\n<p>Since initializers are executed for each new instance, you don't have to worry about objects or arrays being shared across instances as you would if they were specified on an object prototype, which alleviates a common point of confusion for people using JavaScript \\\"class-like\\\" inheritance libraries that specify properties on the prototype.</p>\\n<p>When using constructors, properties may be declared and initialized through the constructor definition by prefixing parameters with an access modifier and/or <code>readonly</code>:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass DomesticatedDog extends Dog {\\r\\n  toys: Toy[] = [];\\r\\n\\r\\n  constructor(\\r\\n    public name: string,\\r\\n    readonly public age: number,\\r\\n    public collarType: string\\r\\n  ) { }\\r\\n}\\r\\n</pre>\\n<p>Here the name, age, and collarType constructor parameters will become class properties, and will be initialized with the parameter values.</p>\\n<p><strong>Typing </strong><strong>this</strong></p>\\n<p>TypeScript can infer the type of <code>this</code> in normal class methods. In places where it can't be inferred, such as nested functions, <code>this</code> will default to the <code>any</code> type. The type of <code>this</code> can be specified by providing a fake first parameter in a function type.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Dog {\\r\\n  name: string;\\r\\n  bark: () =&gt; void;\\r\\n\\r\\n  constructor(name: string) {\\r\\n    this.name = name;\\r\\n    this.bark = this.createBarkFunction();\\r\\n  }\\r\\n\\r\\n  createBarkFunction() {\\r\\n    return function(this: Dog) {\\r\\n      console.log(`${this.name} says hi!`);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>Setting the <code>noImplicitThis</code> compiler flag will cause TypeScript to emit a compiler error whenever <code>this</code> would default to the <code>any</code> type.</p>\\n<p><strong>Multiple inheritance and mixins</strong></p>\\n<p>In TypeScript, interfaces can extend other interfaces <em>and</em> classes, which can be useful when composing complex types, especially if you are used to writing mixins and using multiple inheritance:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ninterface Chimera extends Dog, Lion, Monsterish {}\\r\\n\\r\\nclass MyChimera implements Chimera {\\r\\n  bark: () =&gt; string;\\r\\n  roar: () =&gt; string;\\r\\n  terrorize(): void {\\r\\n    // ...\\r\\n  }\\r\\n  // ...\\r\\n}\\r\\n\\r\\nMyChimera.prototype.bark = Dog.prototype.bark;\\r\\nMyChimera.prototype.roar = Lion.prototype.roar;\\r\\n</pre>\\n<p>In this example, two classes (<code>Dog</code> and <code>Lion</code>) and an interface (<code>Monsterish</code>) have been combined into a new <code>Chimera</code> interface. The <code>MyChimera</code> class implements that interface, delegating back to the original classes for function implementations. Note that the <code>bark</code> and <code>roar</code> methods are actually defined as properties rather than methods; this allows the interface to be \\\"fully implemented\\\" by the class despite the concrete implementation not actually existing within the class definition. This is one of the more advanced use cases for classes in TypeScript, but it enables extremely robust and efficient code reuse when used properly.</p>\\n<p>TypeScript is also able to handle typings for ES2015 <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins\\\">mixin classes</a>. A mixin is a function that takes a constructor and returns a new class (the mixin class) that is an extension of the constructor.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass Dog extends Animal {\\r\\n  name: string;\\r\\n\\r\\n  constructor(name: string) {\\r\\n    this.name = name;\\r\\n  }\\r\\n}\\r\\n\\r\\ntype Constructor&lt;T = {}&gt; = new (...args: any[]) =&gt; T;\\r\\n\\r\\nfunction canRollOver&lt;T extends Constructor&gt;(Animal: T) {\\r\\n  return class extends Animal {\\r\\n    rollOver() {\\r\\n      console.log(&quot;rolled over&quot;);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nconst TrainedDog = canRollOver(Dog);\\r\\nconst rover = new TrainedDog(&quot;Rover&quot;);\\r\\n\\r\\nrover.rollOver();  // valid\\r\\nrover.rollsOver(); // Error: Property 'rollsOver' does not exist on type ...\\r\\n</pre>\\n<p>The type of <code>rover</code> will be <code>Dog & (mixin class)</code>, which is effectively Dog with a <code>rollOver</code> method.</p>\\n<p><strong>Enums</strong></p>\\n<p>TypeScript includes an <a href=\\\"https://www.typescriptlang.org/docs/handbook/enums.html#enums\\\">enum</a> type that allows for efficient representation of sets of constant values. For example, from the TypeScript specification, an enumeration of possible styles to apply to text might look like this:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nenum Style {\\r\\n  NONE = 0,\\r\\n  BOLD = 1,\\r\\n  ITALIC = 2,\\r\\n  UNDERLINE = 4,\\r\\n  EMPHASIS = Style.BOLD | Style.ITALIC,\\r\\n  HYPERLINK = Style.BOLD | Style.UNDERLINE\\r\\n}\\r\\n</pre>\\n<p>Enums can be initialized with constants or via computed values, or they can be auto-initialized, or a mix of initializations. Note that auto-initialized entries must come before entries initialized with computed values.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nenum Directions {\\r\\n  North, // will have value 0\\r\\n  South, // will have value 1\\r\\n  East = getDirectionValue(),\\r\\n  West = 10\\r\\n}\\r\\n</pre>\\n<p>Enum values can also be strings, or a mix of numbers and strings.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nenum Color {\\r\\n  Red = &quot;RED&quot;,\\r\\n  Green = &quot;GREEN&quot;,\\r\\n  Blue = &quot;BLUE&quot;\\r\\n}\\r\\n</pre>\\n<p>Numeric enums are two-way maps, so you can determine the name of an enumerated value by looking it up in the enum object. For example, using the <code>Style</code> above example, <code>Style[1]</code> would evaluate to 'BOLD'. String-initialized enums cannot be reverse mapped.</p>\\n<p>Enums are real objects, not just typing constructs, so they exist at runtime, and incur some runtime cost. That isn't normally a problem, but for cases where constraints are tight, <code>const enum</code> may help. When <code>const</code> is applied to <code>enum</code>, the compiler will replace all uses of the enum with literal values at compile time, so that no runtime cost is incurred. Note that all entries in a <code>const enum</code> must be auto-initialized or be initialized with constant expressions (no computed values).</p>\\n<p><strong>Ambient declarations</strong></p>\\n<p>Statically typed code is great, but there are still some libraries that don't include typings. TypeScript can work with these out of the box, but without the full benefit of typed code. Luckily, TypeScript also has a mechanism for adding types to legacy and/or external code: <a href=\\\"https://www.typescriptlang.org/docs/handbook/modules.html#working-with-other-javascript-libraries\\\">ambient declarations</a>.</p>\\n<p>Ambient declarations describe the types, or \\\"shape\\\", of existing code, but don't provide an implementation. Various constructs, such as variables, classes, and functions, can be declared using the keyword <code>declare</code>. For example, the global variable installed by jQuery is defined in the jQuery typings on <a href=\\\"https://github.com/DefinitelyTyped/DefinitelyTyped\\\">DefinitelyTyped</a> (a public repository of third party typings for JavaScript packages) as:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndeclare const jQuery: JQueryStatic;\\r\\ndeclare const $: JQueryStatic;\\r\\n</pre>\\n<p>When these typings are included in a project, TypeScript will understand that there are <code>jQuery</code> and <code>$</code> global variables with the type <code>JQueryStatic</code>.</p>\\n<p>One of the most common use cases for ambient types is to provide typings for entire modules or packages. For example, assume we have a \\\"vetUtils\\\" package that exports some classes useful for veterinary applications, like Pet and Dog. An ambient module declaration for the vetUtils module would look like:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndeclare module &quot;vetUtils&quot; {\\r\\n  export class Pet {\\r\\n    id: string;\\r\\n    name: string;\\r\\n    constructor(id: string, name: string);\\r\\n  }\\r\\n\\r\\n  export class Dog extends Pet {\\r\\n    bark(): void;\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p>Assuming the declaration above was in a file <code>vetUtils.d.ts</code> that was included in a project, TypeScript would use the typings in the ambient declaration whenever a module imported resources from \\\"vetUtils\\\". Note the <code>d.ts</code> extension. This is the extension for a <a href=\\\"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#find-and-install-declaration-files\\\">declaration file</a>, which can only contain types, no actual code. Since these files only contain type declarations, TypeScript does not generate compiled code for them.</p>\\n<p>For ambient declarations to be useful, TypeScript needs to know about them. There are two ways to explicitly let the TS compiler know about declaration files. One is to include declaration files directly in the compilation with the <code>files</code> or <code>include</code> directives in the <code>tsconfig.json file</code>. The other is with a reference <a href=\\\"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-path-\\\">triple-slash directive</a> at the top of a source file:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n/// &lt;reference types=&quot;jquery&quot; /&gt;\\r\\n/// &lt;reference path=&quot;../types/vetUtils&quot; /&gt;\\r\\n</pre>\\n<p>These comments tell the compiler that a declaration file needs to be loaded. The <code>types</code> form looks for types in packages, similar to how module importing works. The <code>path</code> form gives a path to a declaration file. In both cases, the compiler will identify the directives during preprocessing and add the declaration files to the compilation.</p>\\n<p>The TS compiler will also look for type declarations in specific locations. By default, it will load ambient types in any package under <code>node_modules/@types</code>. So, for example, if a project includes the <code>@types/node</code> package, the compiler will have type definitions for standard Node modules such as <code>fs</code> and <code>path</code>, as well as for global values like <code>process</code>.</p>\\n<p>The set of directories TS looks to for types may be configured with the <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#typeRoots\\\">typeRoots</a></code> compiler option. A similar <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#types\\\">types</a></code> option can be used to specify which types of packages are loaded. In both cases, the options will replace the default behavior. If <code>typeRoots</code> is specified, <code>node_modules/@types</code> will not be included unless it's listed in <code>typeRoots</code>. Similarly if types were set to [\\\"node\\\"], only the node typings would be automatically loaded, even if more types were available in <code>node_modules/@types</code> (or whatever directories were in <code>typeRoots</code>).</p>\\n<p><strong>Loader plugins</strong></p>\\n<p>If you're an AMD user, you'll probably be used to working with <a href=\\\"https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins\\\">loader plugins</a> (<code>text!</code> and the like). TypeScript doesn't understand plugin style module identifiers, and although it can emit AMD code with this type of module ID, it can't load and parse the referenced modules for type checking purposes, at least not without some help. Originally, that meant <code>amd-dependency</code> triple-slash directives:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n/// &lt;amd-dependency path=&quot;text!foo.html&quot; name=&quot;foo&quot; /&gt;\\r\\n\\r\\ndeclare const foo: string;\\r\\nconsole.log(foo);\\r\\n</pre>\\n<p>This directive tells TypeScript that it should add a <code>text!foo.html</code> dependency to the emitted AMD code, and that the name for the loaded dependency should be \\\"foo\\\".</p>\\n<p>Since TypeScript 2, though, the preferred way to handle AMD dependencies is with <a href=\\\"https://www.typescriptlang.org/docs/handbook/modules.html#wildcard-module-declarations\\\">wildcard modules</a> and imports. In a <code>.d.ts</code> file, a wildcard module declaration describes how all imports through the plugin behave. For the <code>text</code>, plugin, an import will result in a string:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\ndeclare module &quot;text!*&quot; {\\r\\n  let text: text;\\r\\n  export default text;\\r\\n}\\r\\n</pre>\\n<p>Any files that need to use the plugin can then use standard import statements:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">import foo from &quot;text!foo.html&quot;;</pre>\\n<p><strong>JSX support</strong></p>\\n<p>TypeScript started becoming popular not long after React, and it gained support for React's <a href=\\\"https://www.typescriptlang.org/docs/handbook/jsx.html\\\">JSX syntax</a> (including the ability to type check it) in version 1.6. To use JSX syntax in TypeScript, code must be in a file with a <code>.tsx</code> extension, and the <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#jsx\\\">jsx</a></code> compiler option must be enabled.</p>\\n<p>TypeScript is a compiler, and by default it transforms JSX to standard JS using the <code>React.createElement</code> API. For interoperability in different build scenarios, it can also emit JSX in <code>.jsx</code> files, or JSX in <code>.js</code> files, configurable with the <code>jsx</code> option. The factory function can also be changed to something other than <code>React.createElement</code> with the <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#jsxFactory\\\">jsxFactory</a></code> option.</p>\\n<p><strong>Control flow analysis</strong></p>\\n<p>TypeScript performs control flow analysis to catch common errors and other issues that can lead to maintenance headaches, including (but not limited to):</p>\\n<ul>\\n<li>unreachable code</li>\\n<li>unused labels</li>\\n<li>implicit returns</li>\\n<li>case clause fall-throughs</li>\\n<li>strict null checking</li>\\n</ul>\\n<p>While having the compiler catch this type of issue can be very helpful, it can be a problem when adding TS to legacy projects. Many of the issues TS can catch don't cause code to fail, but can make it harder to understand and maintain, and existing JS code may have many instances of them. Developers may not want to deal with these issues all at once, so the TS compiler allows these checks to be individually disabled with <a href=\\\"https://www.typescriptlang.org/v2/tsconfig\\\">compiler flags</a> such as <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#allowUnreachableCode\\\">allowUnreachableCode</a></code> and <code><a href=\\\"https://www.typescriptlang.org/v2/tsconfig#noFallthroughCasesInSwitch\\\">noFallthroughCasesInSwitch</a></code>.</p>\\n<p><strong>Compiler comments</strong></p>\\n<p>To make migrating legacy code easier, some special comments can be used to control how TS analyzes specific files or parts of files:</p>\\n<ul>\\n<li><code>// @ts-nocheck</code> - A file with this comment at the top won't be type checked</li>\\n<li><code>// @ts-check</code> - When the checkJs compiler option isn't set, .js files will be processed by the compiler but not type checked. Adding this comment to the top of a .js file will cause it to be type checked.</li>\\n<li><code>// @ts-ignore</code> - Suppress any type checking errors for the following line of code</li>\\n<li><code>// @ts-expect-error</code> - Suppress a type checking error for the following line of code. Raise a compilation error if the following line <em>doesn't</em> having a type checking error.</li>\\n</ul>\\n<p>The <code>@ts-check</code> and <code>@ts-nocheck</code> comments historically only applied to <code>.js</code> files, but as of TS 3.7, <code>@ts-nocheck</code> can also be used for <code>.ts</code> files.</p>\\n<p>The <code>@ts-expect-error</code> comment is new in TS 3.9. It is useful in situations where a developer needs to intentionally use an invalid type, such as in unit tests. For example, a test that validates some runtime behavior may need to call a function with an invalid value. Using the <code>@ts-expect-error</code> comment, the test can call the function with invalid data without generating a compiler warning, <em>and</em> the compiler will also verify that the function's input is properly typed.</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n// src/util.ts\\r\\n\\r\\nfunction checkValue(val: string): boolean {\\r\\n  // ...\\r\\n}\\r\\n</pre>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n// tests/unit/util.ts\\r\\n\\r\\ntest('checkName with invalid data', () =&gt; {\\r\\n  // @ts-expect-error\\r\\n  assert.isFalse(checkValue(5));\\r\\n});\\r\\n</pre>\\n<p>The <code>@ts-ignore</code> comment could also be used to suppress the error in the example above. However, using <code>@ts-expect-error</code> lets the compiler alert the developer if the argument types to <code>checkValue</code> change. For example, if <code>checkValue</code> was updated to accept <code>string | number</code>, the compiler would emit an error for the test code because <code>checkValue(5)</code> no longer caused the expected type error. That would be actionable information since <code>checkValue(5)</code> was no longer properly testing the invalid data case.</p>\\n<p><strong>In conclusion</strong></p>\\n<p>Our <a href=\\\"https://www.sitepen.com/blog/2014/08/22/advanced-typescript-concepts-classes-types/\\\">Advanced TypeScript</a> post goes into more depth exploring how to use TypeScript's class system, and explores some of TypeScript's advanced features, such as symbols and decorators.</p>\\n<p>As TypeScript continues to evolve, it brings with it not just static typing, but also new features from the current and future ECMAScript specifications. This means you can safely start using TypeScript today without worrying that your code will need to be overhauled in a few months, or that you'll need to switch to a new compiler to take advantage of the latest and greatest language features. Any breaking changes are described in each version's release notes and in the <a href=\\\"https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes\\\">TypeScript wiki</a>.</p>\\n<p>For more detail on any of the features described in this guide, the <a href=\\\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md\\\">TypeScript Language Specification</a> is the authoritative resource on the language itself. <a href=\\\"http://stackoverflow.com/questions/tagged/typescript\\\">Stack Overflow</a> is also an excellent place to discuss TypeScript and ask questions, and the official <a href=\\\"http://www.typescriptlang.org/Handbook\\\">TypeScript Handbook</a> can also provide additional insight above and beyond what this guide provides.</p>\\n<p><strong>Learning more</strong></p>\\n<p>With the increased pace of development of JavaScript over the last few years, we believe it's more important than ever to understand the fundamentals of ES2015+ and TypeScript so that new features can be effectively leveraged in web applications. SitePen is happy to provide you or your company with help <a href=\\\"https://www.sitepen.com/our-work/\\\">developing your next application</a>; just <a href=\\\"https://www.sitepen.com/contact/\\\">give us a holler</a> to get started!</p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Originally published Oct 29, 2018. Updated May 29, 2020. This article describes the features and functionality of TypeScript 3.9.  One of the most interesting languages for large-scale application development is Microsoft&#8217;s TypeScript. TypeScript is unique in that it is a superset of JavaScript, but with optional types, interfaces, generics, and more. Unlike other compile-to-JavaScript languages, TypeScript [&hellip;]</p>\\n\",\"protected\":false},\"author\":51,\"featured_media\":22079,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[3,333,11],\"tags\":[],\"series\":[463],\"jetpack_featured_media_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>The Definitive TypeScript Guide | SitePen</title>\\n<meta name=\\\"description\\\" content=\\\"Originally published Oct 29, 2018. Updated May 29, 2020. This article describes the features and functionality of TypeScript 3.9.   One of the most interesting languages for large-scale application development is Microsoft&#039;s TypeScript. TypeScript is unique in that it is a superset of JavaScript, but with optional types\\\" />\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"The Definitive TypeScript Guide | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"Originally published Oct 29, 2018. Updated May 29, 2020. This article describes the features and functionality of TypeScript 3.9.   One of the most interesting languages for large-scale application development is Microsoft&#039;s TypeScript. TypeScript is unique in that it is a superset of JavaScript, but with optional types\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2020-04-10T16:30:26+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-05-29T16:46:35+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1200\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"630\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\",\\\"width\\\":1200,\\\"height\\\":630,\\\"caption\\\":\\\"The Definitive TypeScript Guide\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/\\\",\\\"name\\\":\\\"The Definitive TypeScript Guide | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/#primaryimage\\\"},\\\"datePublished\\\":\\\"2020-04-10T16:30:26+00:00\\\",\\\"dateModified\\\":\\\"2020-05-29T16:46:35+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/c6c5a850ef09b6170f40dc435057d591\\\"},\\\"description\\\":\\\"Originally published Oct 29, 2018.\\\\u00a0Updated May 29, 2020. This article describes the features and functionality of TypeScript 3.9.\\\\u00a0 One of the most interesting languages for large-scale application development is Microsoft's TypeScript. TypeScript is unique in that it is a superset of JavaScript, but with optional types\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/update-the-definitive-typescript-guide/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/c6c5a850ef09b6170f40dc435057d591\\\",\\\"name\\\":\\\"Jason Cheatham\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Jason Cheatham\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/16368\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/51\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=16368\"}],\"version-history\":[{\"count\":15,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/16368/revisions\"}],\"predecessor-version\":[{\"id\":24605,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/16368/revisions/24605\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/22079\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=16368\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=16368\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=16368\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=16368\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":51,\"name\":\"Jason Cheatham\",\"url\":\"\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/jcheatham/\",\"slug\":\"jcheatham\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Jason Cheatham, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Jason Cheatham, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/jcheatham/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/jcheatham/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/jcheatham/\\\",\\\"name\\\":\\\"Jason Cheatham, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/c6c5a850ef09b6170f40dc435057d591\\\",\\\"name\\\":\\\"Jason Cheatham\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/27ad4194c35370123fd3544be84199c6?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Jason Cheatham\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/jcheatham/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/51\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"id\":22079,\"date\":\"2020-01-23T07:21:38\",\"slug\":\"the-definitive-typescript-guide\",\"type\":\"attachment\",\"link\":\"https://wp.sitepen.com/blog/update-the-definitive-typescript-guide/the-definitive-typescript-guide/\",\"title\":{\"rendered\":\"The Definitive TypeScript Guide\"},\"author\":5,\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.7 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>The Definitive TypeScript Guide | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"The Definitive TypeScript Guide | SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-01-23T15:21:44+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1200\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"630\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg#webpage\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\",\\\"name\\\":\\\"The Definitive TypeScript Guide | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"datePublished\\\":\\\"2020-01-23T15:21:38+00:00\\\",\\\"dateModified\\\":\\\"2020-01-23T15:21:44+00:00\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\\\"]}]}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"caption\":{\"rendered\":\"\"},\"alt_text\":\"The Definitive TypeScript Guide\",\"media_type\":\"image\",\"mime_type\":\"image/jpeg\",\"media_details\":{\"width\":1200,\"height\":630,\"file\":\"2018/10/The-Definitive-TypeScript-Guide.jpg\",\"sizes\":{\"medium\":{\"file\":\"The-Definitive-TypeScript-Guide-300x158.jpg\",\"width\":300,\"height\":158,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide-300x158.jpg\"},\"large\":{\"file\":\"The-Definitive-TypeScript-Guide-1024x538.jpg\",\"width\":1024,\"height\":538,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide-1024x538.jpg\"},\"thumbnail\":{\"file\":\"The-Definitive-TypeScript-Guide-150x150.jpg\",\"width\":150,\"height\":150,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide-150x150.jpg\"},\"medium_large\":{\"file\":\"The-Definitive-TypeScript-Guide-768x403.jpg\",\"width\":768,\"height\":403,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide-768x403.jpg\"},\"full\":{\"file\":\"The-Definitive-TypeScript-Guide.jpg\",\"width\":1200,\"height\":630,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\"}},\"image_meta\":{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"1\",\"keywords\":[]}},\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2018/10/The-Definitive-TypeScript-Guide.jpg\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/22079\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/attachment\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/5\"}]}}]}}]","headers":[["access-control-allow-headers","Authorization, X-WP-Nonce, Content-Disposition, Content-MD5, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages, Link"],["allow","GET"],["cache-control","max-age=2592000"],["connection","close"],["content-type","application/json; charset=UTF-8"],["date","Tue, 25 Aug 2020 13:17:27 GMT"],["expires","Thu, 24 Sep 2020 13:17:27 GMT"],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","Apache"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.21-1+0~20200807.66+debian9~1.gbp18a1c2"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}