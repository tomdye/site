{"value":{"body":"[{\"id\":374,\"date\":\"2008-06-17T00:04:14\",\"date_gmt\":\"2008-06-17T07:04:14\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/2008/06/17/json-referencing-in-dojo/\"},\"modified\":\"2008-06-17T00:04:14\",\"modified_gmt\":\"2008-06-17T07:04:14\",\"slug\":\"json-referencing-in-dojo\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/json-referencing-in-dojo/\",\"title\":{\"rendered\":\"JSON Referencing in Dojo\"},\"content\":{\"rendered\":\"<p><img src=\\\"https://wp.sitepen.com/wp-content/uploads/2008/06/references.png\\\" style=\\\"float:right\\\" alt=\\\"references.png\\\" /><br />\\nNon-trivial data often has structures that cannot be well-defined with normal linear, acyclic data descriptions. Data that consists of cycles, many-to-one relationships, and non-local references often requires custom strategies for serialization and transfer of the data over JSON. <a href=\\\"http://dojotoolkit.org\\\">Dojo </a>1.2 has added support for <a href=\\\"http://www.json.com/2007/10/19/json-referencing-proposal-and-library/\\\">JSON referencing</a> with the dojox.json.ref module. This module provides support for several forms of referencing including circular, multiple, inter-message, and lazy referencing using id, path, and combined referencing forms.</p>\\n<p>These references can be automatically generated on serialization and resolved on deserialization. JSON referencing is designed to decouple the topology of data structures from the meaning of the data structures in a way that is consistent with runtime object models of modern OO languages (foremost JavaScript). Separating graph connectedness concerns allows referencing and dereferencing to be handled by dojox.json.ref with minimal or no knowledge of and integration with higher level JSON consumers and producers, and permits more extensive JavaScript serialization capabilities.</p>\\n<p><!--more--></p>\\n<h3>dojox.json.ref API</h3>\\n<p>First we will look at how to use the new module to serialize JavaScript objects. Perhaps the simplest data structure that requires referencing is a circular reference. We can easily create an object with a circular reference in JavaScript:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\nvar obj = {};\\nobj.me = obj;\\n</pre>\\n<p>Most JSON libraries cannot serialize such an object, and will generally result in a stack overflow error. However, we can serialize this with dojox.json.ref:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\nvar jsonWithCircularRef = dojox.json.ref.toJson(obj);\\n</pre>\\n<p>And de-serialize the JSON back to an object:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\nobj = dojox.json.ref.fromJson(jsonWithCircularRef);\\nobj.me == obj // -&gt; true, the reproduced object will\\n\\t//have a property named &quot;me&quot; with a value of itself.\\n</pre>\\n<p>Another common data topology is multiple references:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\nvar me = {\\n\\tname:&quot;Kris&quot;,\\n\\tfather:{name:&quot;Bill&quot;},\\n\\tmother:{name:&quot;Karen&quot;}};\\nme.father.wife = me.mother;\\nvar jsonMe = dojox.json.ref.toJson(me); // serialize me\\nvar newMe = dojox.json.ref.fromJson(jsonMe); // de-serialize me\\nnewMe.father.wife == newMe.mother // -&gt; true, the reproduced object will\\n\\t\\t\\t// properly reproduce both references to the same object.\\n</pre>\\n<h3>JSON Referencing Convention</h3>\\n<p>Now we will look at how to create JSON with references that can be parsed and resolved by <code>dojox.json.ref</code>. The JSON referencing format is primarily based on a reference object which is a special JSON object with a single property named <em>$ref</em> with a value indicating the target of the reference. The simplest way to create references is with id references. This is done by adding ids to objects, and then referencing the object by id. A JSON object with a circular reference as in the first example would look like:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"id\\\":\\\"1\\\",\\\"me\\\":{\\\"$ref\\\":\\\"1\\\"}}\\n</pre>\\n<p>This could be loaded from a file, and then de-serialized by calling:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\ndojox.json.ref.fromJson(jsonFromFile)\\n</pre>\\n<p>We could also reproduce the second example with id-based referencing:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"name\\\":\\\"Kris\\\",\\n  \\\"father\\\":{\\\"name\\\":\\\"Bill\\\",\\\"wife\\\":{\\\"$ref\\\":\\\"2\\\"}},\\n  \\\"mother\\\":{\\\"name\\\":\\\"Karen\\\",\\\"id\\\":\\\"2\\\"}}\\n</pre>\\n<h4>Path-Based Referencing</h4>\\n<p>Id-based referencing is convenient and readable in situations where objects already have an existing identity property. However, when objects do not already have an identity property, generating ids for every object that might be referenced can be difficult, verbose, time-consuming, and may generate extra properties that could interfere with the intended structure of the data. In these situations, path-based referencing is a cleaner approach. Path-based referencing is inspired by <a href=\\\"http://goessner.net/articles/JsonPath/\\\">JSONPath</a>, which is a language agnostic convention for querying JSON data, with a syntax that is similar to JavaScript (and <a href=\\\"https://www.sitepen.com/blog/2008/03/17/jsonpath-support/\\\">supported by Dojo</a>). With a path-based reference, <em>#</em> denotes the root of the JSON object, and <em>.property</em> and <em>[&#8216;property&#8217;]</em> syntax are used to denote property values in the JSON object. Therefore, to create the circular reference example with path-based referencing:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"me\\\":{\\\"$ref\\\":\\\"#\\\"}}\\n</pre>\\n<p>And to create the multiple reference example with path-based referencing:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"name\\\":\\\"Kris\\\",\\n  \\\"father\\\":{\\\"name\\\":\\\"Bill\\\",\\\"wife\\\":{\\\"$ref\\\":\\\"#mother\\\"}},\\n  \\\"mother\\\":{\\\"name\\\":\\\"Karen\\\"}}\\n</pre>\\n<h4>Combined Path/Id Referencing</h4>\\n<p>Id and path based referencing can be combined. Rather than starting a path reference with the <em>#</em> root reference, a path reference may begin with an id reference. For example one could have a reference:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"$ref\\\":\\\"5.foo.bar\\\"}\\n</pre>\\n<p>This would indicate that this reference should be resolved by finding the object with an id of &#8220;5&#8221;, and finding the value of the <em>foo</em> property of that object and then finding the value of <em>bar </em>property of that value. Combined path/id referencing can be very valuable in situations where not all objects have ids. In particular, it is impossible to give keyed properties (and consequently ids) to arrays with JSON, so combining path/id referencing can be essential in referencing arrays and values in arrays when id referencing is necessary (inter-message referencing).</p>\\n<p><code>dojox.json.ref.toJson</code> will automatically determine the optimum referencing technique to use when serializing JavaScript objects. If ids are present on objects, than id-based referencing (or combined) will be used, otherwise path-based referencing is used. In the first example where a JavaScript object was serialized, path-based referencing would be used since there were no ids on the objects. <code>dojox.json.ref.fromJson</code> can also automatically handle all three forms of referencing.</p>\\n<h3>Inter-Message Referencing</h3>\\n<p>Referencing is not limited to within a single JSON string/message.  References can be made to other objects that have been de-serialized in previous (or future) messages. This can be very important for preserving identity of referenced objects as well as reducing the amount of data that must be transmitted. For example if we loaded an object describing me from a server:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">{\\\"name\\\":\\\"Kris\\\",\\n \\\"father\\\":{\\n    \\\"id\\\":\\\"bill\\\",\\n    \\\"name\\\":\\\"Bill\\\"}\\n}</pre>\\n<p>And in the next message, we loaded an object describing my sister, we would the object to reference the same father object (and not have to download it again):</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"name\\\":\\\"Kari\\\",\\n \\\"father\\\":{\\\"$ref\\\":\\\"bill\\\"}\\n}</pre>\\n<p>When <code>dojox.json.ref.fromJson()</code> parses the second JSON message, it should resolve the reference to the object that it created for my father in the first message. <code>firstObject.father</code> should be equal to <code>secondObject.father</code> and resolve references from the other. Not only does this preserve object identity, it can significantly reduce the size of the transferred data by eliminating the need to retransmit large objects that referenced multiple times.</p>\\n<p>Inter-message references are dependent on providing an index map object as a parameter to fromJson() (see the API description below). If the same index object is provided, than the inter-message references can be resolved.  Otherwise references will be limited to that message. The new JsonRestStore module uses the Rest service with the referencing module, and a single index is used across Rest requests with automatic contextualization.</p>\\n<h3>Lazy Referencing</h3>\\n<p><code>dojox.json.ref</code> also allows objects to reference other objects that have not been loaded and parsed yet. For example, if this object comes first:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"name\\\":\\\"Kari\\\",\\n  \\\"father\\\":{\\\"$ref\\\":\\\"bill\\\"}\\n}</pre>\\n<p>Then the father property will be a lazy reference to an object that has not been loaded yet. Lazy references are denoted with a special <a href=\\\"http://api.dojotoolkit.org/jsdoc/dojo/HEAD/dojo.Deferred\\\">dojo.Deferred</a> value. Lazy referencing can be used in conjunction with the <code>dojox.rpc.Rest</code> service to automatically load referenced values when they are needed. To load a lazy value, simply a callback listener using <code>addCallback</code> to the Deferred object. As soon as the <code>addCallback</code> is called, the referenced value will be loaded, if it has not already been loaded. Lazy referencing can be valuable for maintaining the topology of JSON object structures, while deferring the loading of large sets of data until necessary, using the standard Dojo concepts of Deferred values.</p>\\n<h3>JSON Referencing + Relative URLs</h3>\\n<p>Using ids within a single logical domain can limit the scope of referencing. Data stores may wish to reference data accessible from different paths, and decentralized cross-site data structures may be advantageous. <code>dojox.json.ref</code> supports standard ids along with references outside of origin id domain using relative URLs for references. By equating references to relative URLs, references have a natural correspondence to resource location. JSON referencing leverages the ubiquity and flexibility of the standard relative URL convention to extend the scope of potential referents without compromising the simplicity of simple intra-message references.</p>\\n<p>To illustrate with an example, suppose we retrieve the resource from <em>http://mysite.com/Person/1</em> and receive:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"id\\\":\\\"1\\\",\\\"name\\\":\\\"Kris\\\", \\\"father\\\":{\\\"$ref\\\":\\\"2\\\"}}\\n</pre>\\n<p>This is a simple id-based lazy reference, with the <em>father</em> property referencing the object with an id of <em>&#8220;2&#8221;</em> within our context. However, using the concept of relative URLs in conjunction with our knowledge of where the resource was requested we can infer absolute resource locations for the objects and their references. We can determine that the target of the reference can be found at a location of <em>http://mysite.com/Person/2</em>. Note that we didn&#8217;t have to change the syntax of the JSON referencing at all with references within the message and context.</p>\\n</p>\\n<p>Now imagine that we want to load an object that does make a reference to a different context. Suppose, we load a purchase order object from <em>http://mysite.com/PO/1</em>:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"id\\\":\\\"1\\\",\\n \\\"amount\\\":5.99,\\n \\\"purchasedBy\\\":{\\\"$ref\\\":\\\"/Person/1\\\"}\\n}</pre>\\n<p>Now we can use relative URLs to determine that the purchasedBy property is referring to the object from <em>http://mysite.com/Person/1</em>. If this object has already been loaded, the property can be directly resolved by <em>dojox.json.ref.fromJson</em>, and if not, it can create a lazy reference that will load the object from the correct URL as needed. It is important to note that the message and client can remain agnostic of how this reference was formed. The reference may be a result of a relationship in a RDBMS, a direct reference in non-relational databases, or manually created. The client does not need to understand the details of how the reference was formed.</p>\\n<p>We can even go a step further and use cross-site references. Suppose we are a reseller, and we want to actually link directly to the manufacturer&#8217;s data for the products in our purchase order. We might have a purchase order like:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n{\\\"id\\\":\\\"1\\\",\\n \\\"amount\\\":5.99,\\n \\\"purchasedBy\\\":{\\\"$ref\\\":\\\"/Person/1\\\"},\\n \\\"product\\\":{\\\"$ref\\\":\\\"https://www.sitepen.com/t-shirt\\\"}\\n}\\n</pre>\\n<p>This is allows us to maintain a much more <a href=\\\"http://en.wikipedia.org/wiki/Don't_repeat_yourself\\\">DRY</a> data storage system. Once again, <code>dojox.json.ref</code> can handle resolving references and client code can deal directly with the data without concern for the underlying details of recreating the topology of the data structure even if connections span domains.</p>\\n<h3>Additional dojox.json.ref Options</h3>\\n<p>In order for <code>dojox.json.ref</code> to properly handle references that cross messages, domains, and contexts, it is necessary to provide additional information to the functions. <code>dojox.json.ref.fromJson</code> takes the following parameters:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">dojox.json.ref.fromJson(str, args)</pre>\\n<ul>\\n<li>str &#8211; The JSON string to parse</li>\\n<li>args &#8211; A keyword set of arguments that can have the following properties (all are optional):\\n<ul>\\n<li>index &#8211; The index object (map) to use to store an index of all the objects. If you are using inter-message referencing, you must provide the same object for each call.</li>\\n<li>defaultId &#8211; The default id to use for the root object (if it doesn&#8217;t define it&#8217;s own id)</li>\\n<li>idPrefix &#8211; The prefix to use for the ids as they enter the index. This allows multiple tables to use ids (that might otherwise collide) that enter the same global index. For example, if you request an object from the /Person/1, then you should provide an idPrefix of &#8220;/Person/&#8221;.</li>\\n<li>idAttribute &#8211; Indicates what property is the identity property. This defaults to &#8220;id&#8221;. It is recommended that you use &#8220;id&#8221; as the identity property for simplicity and consistency.</li>\\n</ul>\\n</li>\\n</ul>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">dojox.json.ref.resolveJson(object, args)</pre>\\n<p>resolveJson works the same as fromJson, but it operates on a pre-parsed JSON object. Therefore <code>dojox.json.ref.fromJson(str)</code> is roughly the same as <code>dojox.json.ref.resolveJson(eval('('+str+')'))</code></p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">dojox.json.ref.toJson(it, prettyPrint, idPrefix)</pre>\\n<ul>\\n<li>it &#8211; The value to serialize.</li>\\n<li>prettyPrint &#8211; Indicates whether to use a pretty printing of the JSON.</li>\\n<li>idPrefix &#8211; Indicates what context to use for serializing the JSON.</li>\\n</ul>\\n<p><code>dojox.json.ref</code> is used for reference resolution, indexing, and serialization by dojox.data.JsonRestStore. JsonRestStore combines the REST service module with JSON referencing and automatically handles the interaction with <code>dojox.json.ref</code> to provide the proper context and index information to the serializer and de-serializer.</p>\\n<p><code>dojox.json.ref.fromJson</code> also supports a non-JSON, JavaScript syntax, referencing convention. Rather than using:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">...\\nproperty:{\\\"$ref\\\":\\\"reference-target\\\"}\\n...\\n</pre>\\n<p>to define a reference, you can alternately create a reference:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n...\\nproperty:{ref(\\\"reference-target\\\")}\\n...\\n</pre>\\n<h3>Performance</h3>\\n<p>JSON referencing adds additional processing to the serialization and de-serialization process, so it inevitably is slower than standard <code>dojo.toJson</code> and <code>dojo.fromJson</code>. The <code>dojox.json.ref.fromJson</code> is approximately 2-3 times slower than standard <code>dojo.fromJson</code>. However, <code>fromJson</code> is usually used for parsing data sent from a server, and <code>dojox.json.ref.fromJson</code> is generally still faster than most download speeds. For example, on IE8, <code>dojox.json.ref.fromJson</code> can parse JSON at about 1MB per second (of course, this is highly dependent on the structure of the data). When referencing can be used to eliminate redundancy in JSON messages, the performance gains due to the reduced data transfer can easily outweigh the extra client side processing costs. <code>dojox.json.ref</code> also simultaneously indexes objects as it is parsing, and this capability is leveraged by the new JsonRestStore to avoid any extra steps of indexing, generally canceling any client side processing performance hits in such situations.</p>\\n<p>dojox.json.ref.toJson has a negligible performance hit in comparison to the standard dojo.toJson (less than 5%).</p>\\n<h2>Conclusion</h2>\\n<p>Dojo&#8217;s new support for JSON referencing allows a wide range of referencing possibilities using a consistent simple convention, and permits much more flexibility in describing complex data structures and serializing JavaScript data.</p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Non-trivial data often has structures that cannot be well-defined with normal linear, acyclic data descriptions. Data that consists of cycles, many-to-one relationships, and non-local references often requires custom strategies for serialization and transfer of the data over JSON. Dojo 1.2 has added support for JSON referencing with the dojox.json.ref module. This module provides support for [&hellip;]</p>\\n\",\"protected\":false},\"author\":28,\"featured_media\":17535,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[46,45,3,16],\"tags\":[113,121,122,114],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.5 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>JSON Referencing in Dojo | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"JSON Referencing in Dojo | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"Non-trivial data often has structures that cannot be well-defined with normal linear, acyclic data descriptions. Data that consists of cycles, many-to-one relationships, and non-local references often requires custom strategies for serialization and transfer of the data over JSON. Dojo 1.2 has added support for JSON referencing with the dojox.json.ref module. This module provides support for [&hellip;]\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2008-06-17T07:04:14+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/\\\",\\\"name\\\":\\\"JSON Referencing in Dojo | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/#primaryimage\\\"},\\\"datePublished\\\":\\\"2008-06-17T07:04:14+00:00\\\",\\\"dateModified\\\":\\\"2008-06-17T07:04:14+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\"},\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/json-referencing-in-dojo/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/374\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=374\"}],\"version-history\":[{\"count\":0,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/374/revisions\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/17535\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=374\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=374\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=374\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=374\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":28,\"name\":\"Kris Zyp\",\"url\":\"https://www.sitepen.com\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/kzyp/\",\"slug\":\"kzyp\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.5 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Kris Zyp, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Kris Zyp, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/kzyp/\\\",\\\"name\\\":\\\"Kris Zyp, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cache-control","max-age=2592000"],["connection","close"],["content-type","application/json; charset=UTF-8"],["date","Sat, 01 Aug 2020 15:34:50 GMT"],["expires","Mon, 31 Aug 2020 15:34:50 GMT"],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","Apache"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-powered-by","PHP/7.3.16-1+0~20200320.56+debian9~1.gbp370a75"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}