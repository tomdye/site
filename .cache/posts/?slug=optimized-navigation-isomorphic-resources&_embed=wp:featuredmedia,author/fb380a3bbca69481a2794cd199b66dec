{"value":{"body":"[{\"id\":10421,\"date\":\"2015-02-27T08:14:25\",\"date_gmt\":\"2015-02-27T15:14:25\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=10421\"},\"modified\":\"2015-02-27T08:14:25\",\"modified_gmt\":\"2015-02-27T15:14:25\",\"slug\":\"optimized-navigation-isomorphic-resources\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/optimized-navigation-isomorphic-resources/\",\"title\":{\"rendered\":\"Optimized Navigation: Isomorphic Resources\"},\"content\":{\"rendered\":\"<p>When building web applications, developers often face the dilemma of whether to use traditional server-side rendered pages, or client-centric applications that rely on Ajax/JSON data requests, with client-side rendering of data. These two approaches also tend to dictate navigation (among other things), leading to traditional page navigation or a single-page application (perhaps with hash-based navigation). With the traditional approach, content is delivered in HTML form, relying on browser-driven page loads for different views. However, modern applications with more sophisticated user interfaces, often use a single-page style, controlling events, view updates, and relying on Ajax-style communication with the server to load additional content, typically in structured object format, like JSON. The traditional approach naturally works well with search engines, and browser navigation and can be quickly rendered by the browser. Single-page applications facilitate well structured user interfaces, with clean separation of presentation and data. But is there a way to combine the best of both worlds?</p>\\n<p><!--more--></p>\\n<p>Some applications have attempted to combine these approaches by rendering some content on the server to HTML, and some on the client-side. Others have attempted to render the same code on both the server and client, sometimes called &#8220;isomorphic JavaScript.&#8221; But in this post, we will demonstrate a strategy for delivering content in a simple object-oriented HTML format, that minimizes server complexity, maximizes loading performance and scalability, and still preserves the consolidation of primary UI logic on the client, for easy management of user interaction and state. We will also look at combining this strategy with modern browser techniques, leveraging HTML5 microdata and the page history API. This will enable fast, searchable pages while still retaining the architecture of single-page applications with a single clean presentation codebase based on client-side rendering of structured data.</p>\\n<h2>A Comparison</h2>\\n<p>To approach this strategy, let&#8217;s review the benefits of each the two main approaches. First, traditional pages:</p>\\n<ul>\\n<li>Browsers can immediately begin rendering, without waiting for JavaScript to load and execute.</li>\\n<li>Page navigation naturally works, with easy bookmarking and back/forward support.</li>\\n<li>Pages can easily be indexed by search engines.</li>\\n</ul>\\n<p>And advantages of single-page applications:</p>\\n<ul>\\n<li>Rendering processing is distributed to clients, reducing server workload, and improving scalability</li>\\n<li>UI code is easier to write since it is on one machine, making it easier to create data models, preserve state, etc.</li>\\n<li>Page navigation can be quicker, since only the raw content needs to be retrieved, without any page reloading or rerendering.</li>\\n<li>Content can be transferred in object format, retaining the same conceptual form we generally use in programming.</li>\\n</ul>\\n<p>From this list of advantages, let&#8217;s assimilate a strategy that can combine these benefits:</p>\\n<ul>\\n<li>Deliver content in HTML for initial page load</li>\\n<li>Deliver content in JSON for later transitions, keeping in sync with page history</li>\\n<li>Deliver content with minimal presentation/rendering overhead, deferring more complex presentation additions to the client</li>\\n</ul>\\n<p><object type=\\\"image/svg+xml\\\" data=\\\"https://user.sitepen.com/~kzyp/web-app-layers.svg\\\" alt=\\\"web-app-layers\\\" width=\\\"500\\\" height=\\\"460\\\" class=\\\"alignright size-full wp-image-10573\\\" /></object><br />\\nThe last point is key to understanding this approach. Rather than treating &#8220;rendering&#8221; as a single, monolithic transform to the final HTML/DOM structure, we recognize that translation of content into the user interface can be done in granular steps, with the transform of the core content to HTML, as a basic first step, and perhaps the only step that might need to be done on the server. While we won&#8217;t explore every layer that you could employ in an application, you can consider a visualization of how an application rendering could be broken down.</p>\\n<h2>Consistency of Object Structure</h2>\\n<p>So how can we deliver on this strategy? A key feature of the single-page architecture is the use of object structured content that can be rendered through JavaScript views without relying on page reloads. There are a plethora of rendering technologies available, some relying on templating, others on programmatic DOM creation. ReactJS even extends the JavaScript language to provide reactive capabilities for rendering DOM elements with in-language syntax.</p>\\n<p>However, to achieve true page-driven content, we need to deliver the data for a page as HTML. We will do this in a way to retain our structured data directly in the page. Generally, HTML can be an ambiguous and cumbersome source of data, but we can easily define a simple structure for HTML that conveys the natural object structures that we use to store data as well as programmatically interact with data.</p>\\n<p>This approach of using different formats (HTML and JSON) that have clear, minimal, and unambiguous transformations to object structures, could be called <strong>Isomorphic Resources</strong>. The use of these different isomorphic formats can then be optimized for initial (HTML) and later (JSON) usage. Not only is this an alternative to isomorphic JavaScript, but the well-defined mapping of transformations back and forth between different representations actually precisely matches the mathematical definition of <a href=\\\"http://en.wikipedia.org/wiki/Isomorphism\\\">isomorphic</a>. Using multiple formats for a resource is also a best practice of REST architecture.</p>\\n<p>One approach we can use for defining object structures in HTML is to use the <a href=\\\"http://www.w3.org/TR/microdata/\\\">microdata</a> standard, which provides a predictable structure for data such that it can easily be converted to JavaScript objects that can be rendered. Not only can microdata be clearly converted to JavaScript structures, but it can also be clearly interpreted and indexed by search engines, and with even more precision and clarity than standard HTML pages.</p>\\n<p>Again, traditionally, with Ajax applications, JSON is the preferred data format. It is succinct, and can easily and quickly be parsed into JavaScript object structures. And we can still use JSON as we retrieve data dynamically from the page. But, for our initial page load, we will embed the initial data directly in the HTML using microdata semantics, as an alternate format for our data.</p>\\n<h3>Example</h3>\\n<p>Let&#8217;s look at an example to see how we can do this in practice. Imagine we are building an application (or at least a part of an application) that displays a list of different products. We will use a <a href=\\\"http://dgrid.io\\\">dgrid</a> to display the list of products, which is a distinctly sophisticated and commonly used client-side widget. Again, as with single page architecture, once a page is loaded, we typically will want to use JSON to transfer the data. We may setup a RESTful service that provides information on a product by id, responding with JSON:</p>\\n<p>Request:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\nGET /Product/?category=food\\nAccept: application/json\\n</pre>\\n<p>Response:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\n[\\n    {&quot;id&quot;:&quot;oj&quot;, &quot;name&quot;:&quot;Orange Juice&quot;, &quot;price&quot;: 3.49, &quot;quantity&quot;: 65,\\n            &quot;category&quot;: &quot;food&quot;},\\n    {&quot;id&quot;: &quot;bread&quot;, &quot;name&quot;:&quot;Bread&quot;, &quot;price&quot;: 2.99, &quot;quantity&quot;: 32,\\n            &quot;category&quot;: &quot;food&quot;}\\n]\\n</pre>\\n<p>This will work great for our in-page Ajax requests. But we will also setup our server to provide this same data in HTML form, so that we can load a page directly with this data embedded in it. There are numerous ways you could indicate which format to use for a particular product. But, if we want to really adhere to REST/HTTP semantics, we should use the <code>Accept</code> header (although we could certainly use an alternate means of indicating this). We can then make a request to the same resource and get the data back in HTML form. Our strategy here is again to return the bare minimum needed to convey the data, and provide a reasonable presentation/styling of that data while we wait for the JavaScript to load:</p>\\n<p>Request:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\nGET /Product/?category=food\\n</pre>\\n<p>Response:</p>\\n<pre class=\\\"brush: xml; title: ; notranslate\\\" title=\\\"\\\">\\n&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\n    &lt;head&gt;\\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ui.css&quot;&gt;\\n    &lt;/head&gt;\\n    &lt;body&gt;\\n        &lt;table class=&quot;page-content&quot;&gt;\\n            &lt;tr itemscope itemid=&quot;oj&quot;&gt;\\n                &lt;td itemprop=&quot;name&quot;&gt;Orange Juice&lt;/td&gt;\\n                &lt;td itemprop=&quot;price&quot;&gt;3.49&lt;/td&gt;\\n                &lt;td itemprop=&quot;quantity&quot;&gt;65&lt;/td&gt;\\n                &lt;td itemprop=&quot;category&quot;&gt;food&lt;/td&gt;\\n            &lt;/tr&gt;\\n            &lt;tr itemscope itemid=&quot;bread&quot;&gt;\\n                &lt;td itemprop=&quot;name&quot;&gt;Bread&lt;/td&gt;\\n                &lt;td itemprop=&quot;price&quot;&gt;2.99&lt;/td&gt;\\n                &lt;td itemprop=&quot;quantity&quot;&gt;32&lt;/td&gt;\\n                &lt;td itemprop=&quot;category&quot;&gt;food&lt;/td&gt;\\n            &lt;/tr&gt;\\n        &lt;/table&gt;\\n        &lt;script src=&quot;../dojo/dojo.js&quot; async\\n                data-dojo-config=&quot;deps: &amp;#91;'app/main'&amp;#93;, async: true&quot;&gt;\\n        &lt;/script&gt;\\n    &lt;/body&gt;\\n&lt;/html&gt;\\n</pre>\\n<p>It should be clear here how this approach differs from server-side rendering of the user interface. This HTML contains almost no presentation information itself, it is direct, simple output of the data, just in a different format. The presentation of this data is still primarily the responsibility of the client JavaScript code. We do make use of some simple HTML semantics, so we can style this data for reading while the further user interface controls load, but the primary presentation is cleanly encapsulated, and is not spread across server code.</p>\\n<h2>Parsing the Data</h2>\\n<p>Next, we need to be able to actually use this data. With JSON, we simply can pass the data to <code>JSON.parse</code> to parse. With our HTML-based object structure, parsing the data is a little more involved, but certainly not excessively difficult.</p>\\n<p>Let&#8217;s create our top level module, <code>my-app/main</code>, that will parse the page for content, creating an object structure:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\ndefine([\\n    'dojo/_base/declare',\\n    'dojo/dom',\\n    'dojo/query',\\n    'dgrid/OnDemandGrid',\\n    'dstore/Rest',\\n    'dstore/Cache',\\n    'dstore/Memory',\\n    'dojo/domReady!'\\n], function (\\n    declare,\\n    dom,\\n    query,\\n    Grid,\\n    Rest,\\n    Cache,\\n    Memory) {\\n\\n    function parseObjects(rootElement) {\\n        var data = [];\\n        query('[itemscope]', rootElement).forEach(function (itemNode) {\\n            // process each node with an itemscope, indicating a\\n            // corresponding object representation, and set the id\\n            var item = {id: itemNode.getAttribute('itemid')};\\n            query('*', itemNode).forEach(function (propertyNode) {\\n                var propertyName = propertyNode.getAttribute('itemprop');\\n                item[propertyName] = propertyNode.firstChild.nodeValue;\\n            });\\n            // add to our array of objects\\n            data.push(item);\\n        });\\n        return data;\\n    }\\n    var pageContentElement = dom.byId('page-content');\\n\\n    var pageData = parseObjects(pageContentElement);\\n    ...\\n</pre>\\n<h2>Data Store</h2>\\n<p>Next, we will setup a data store to provide this data to our user interface component (the dgrid in this case). The store will provide a key piece of functionality for smoothly and consistently switching between initial page-provided data, and subsequent AJAX-requested data. Using <a href=\\\"http://dstorejs.io/\\\">dstore</a>, We will setup a <code>Cache</code> store that uses the page data as the cache, in conjunction with a <code>Rest</code> store for later interactions with the server:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\n// create cached REST store\\nvar RestCache = declare([Rest, Cache]);\\n// setup the caching store based on the in-page data\\nvar cachingStore = new Memory({\\n    data: pageData\\n});\\n// create our product store with the Rest store and\\n// the prepopulated cache data from the page.\\nvar productStore = new RestCache({\\n    cachingStore: cachingStore\\n});\\n</pre>\\n<p>In this example, we are constructing our data based on the idea that we will be navigating to different &#8220;views&#8221; of the data, corresponding to different filters applied to the data. For example, we might be loading the page with <code>?category=food</code> to find all the food items.</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\n// now we create a collection representing the\\n// current view of the data, a filtered set of product\\n// items by category\\nfunction getCategoryView (category) {\\n    return productStore.filter({\\n        category: category\\n    });\\n}\\nvar initialCategory = location.search.match(/category=([^&amp;]*)/)[1];\\nvar initialCategoryView = getCategoryView(initialCategory);\\n\\n// now we declare that this collection can be satisfied from\\n// data in our cache (the in-page data), we don't need to\\n// make any request for this data from the server\\ninitialCategoryView.isValidFetchCache = initialCategoryView.allLoaded = true;\\n</pre>\\n<h2>User Interface (Grid)</h2>\\n<p>Next we create the user interface component, the dgrid, to display the content with all the behavioral capabilities and functionality that dgrid provides. Now that we have parsed the data from the page content element, we can clear out that element and use it to house the grid:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\nvar pageContentElement = dom.byId('page-content');\\n\\n// clear out the prior content, we have it in object form now,\\n// and we will render the grid in its place.\\npageContentElement.innerHTML = '';\\n\\n// create the grid now\\nvar grid = new Grid({\\n    collection: initialCategoryView,\\n    columns: {\\n        name: 'Name',\\n        price: 'Price',\\n        quantity: 'Quantity'\\n    }\\n}, pageContentElement);\\n</pre>\\n<p>Typically with a dgrid, we will want to <a href=\\\"https://www.sitepen.com/blog/2012/05/03/css-styling-of-dgrid/\\\">style</a> columns in the grid. When we do this we can apply the same styling by including the microdata attributes selectors in our column rules. This will allow us to style the content that appears before our code is actually loaded, and have the same styling applied before and after the grid is instantiated. Again, this helps us to maximize the performance of showing content, in a readable form, before the page is a fully loaded, for a smooth progressive load. For example, we could define the <code>name</code> column to have a width of <code>50%</code> and bold text, using the dgrid and microdata selectors:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\n.field-name, /* the dgrid column selector */\\n.[itemprop=name] { /* microdata selector */\\n    width: 200px;\\n    font-weight: bold;\\n}\\n</pre>\\n<p>At this point, we could now create additional components and controls that are used to interact with the main content. This would include controls for adding, modifying content, or performing other actions (for example, purchasing items). This might also include inputs for performing additional querying or filtering. It could include extra functionality such as real-time chat or status information as well. These are all user interface components that can and should be described outside the content itself.</p>\\n<h2>Navigation</h2>\\n<p>We have now loaded our initial content and rendered it. Next, we need to handle navigation. One of the key benefits of traditional pages is that navigation naturally fits with the browser model of pages, allowing for easy back, forward and bookmark actions. If we are going to provide the best of both approaches, we need to preserve this functionality. In Ajax applications, it is common to use hash based navigation, and if we need to support older browsers, we most likely need to support this as a fallback. However, we can and should leverage the newer HTML5 history APIs to preserve navigation functionality where possible, though it does require support from the server-side to achieve. This new history API allow us to specify real server URLs (not just hashes) to associate with each change in data views in our application.</p>\\n<h3>State Navigation</h3>\\n<p>Traditionally, in-page navigation also relies on hash-based navigation, since it does involve any server coordination. But, fortunately, if we are building on the isomorphic resource approach, where different resources correspond to different views, these URLs can conveniently and correctly map to real server URLs that may be delivered in JSON for an in-page transition, or in HTML for a new page transition.</p>\\n<p>Whenever the user has initiated an action that should lead to presenting a new set of data or view, we go through a navigation process, so that the navigation goes through the browser&#8217;s history. Dojo provides an extensible router component. By default <code>dojo/router</code> will use hash based navigation, but we can readily extend it to implement navigation based on the HTML5 history API. We do this by listening for <code>popstate</code> events, and triggering navigation through the <code>pushState</code> (or <code>replaceState</code>) functions. One additional concern with real paths, is that they may be relative, so we need to handle relativizing URLs.</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\n//HistoryRouter.js:\\ndefine(['dojo/router/RouterBase', 'dojo/_base/declare', 'dojo/on'], function(RouterBase, declare, on){\\n    return declare([RouterBase], {\\n        startup: function(){\\n            if (this._started) { return; }\\n            this.inherited(arguments);\\n            var self = this;\\n\\n            this._handlePathChange(this._computePath());\\n            on(window, 'popstate', function () {\\n                self._handlePathChange(self._computePath());\\n            });\\n        },\\n\\n        basePath: '',\\n\\n        _computePath: function (relativePath) {\\n            // compute full path based on relative path\\n            var url = relativePath ?\\n                new URL(relativePath, location) : location;\\n            return (url.pathname + url.search).slice(this.basePath.length);\\n        },\\n        \\n        go: function(path, replace){\\n            var applyChange;\\n            if(typeof path !== 'string'){\\n                return false;\\n            }\\n\\n            path = this._computePath(path);\\n            applyChange = this._handlePathChange(path);\\n            if (applyChange) {\\n                var state = replace ? 'replaceState' : 'pushState';\\n                history[state]({}, '', path);\\n            }\\n            return applyChange;\\n        }\\n    });\\n});\\n</pre>\\n<h3>Register Navigation Handling</h3>\\n<p>Once we have the routing infrastructure in place, we can register our response to navigation events. From the beginning, we determined the current category from the URL, and use that to select a filtered collection of data from the store, to display in the grid. We can reuse this functionality to determine the current collection and send that to the grid. This can then be implemented in our navigation handler that we register. We will create a new instance of our custom router, and register our handler:</p>\\n<pre class=\\\"brush: plain; title: ; notranslate\\\" title=\\\"\\\">\\nvar router = new HistoryRouter({\\n    // use my current path as the base path, everything after \\n    // the base path is handled by the router paths\\n    basePath: location.pathname\\n});\\nrouter.register('\\\\\\\\?category=:category', function (event) {\\n    // respond to navigating to a new category\\n    var category = event.params.category;\\n    // use the initial category view if we are in the initial category\\n    grid.set('collection', initialCategory === category ?\\n        initialCategoryView : getCategoryView(category));\\n    // update the document title\\n    document.title = category + ' for sale';\\n});\\nrouter.startup();\\n</pre>\\n<p>If we are navigating to a new category, this will automatically trigger a new request to the server for data. Because we did not mark non-initial categories as cached, it won&#8217;t go to the pre-filled memory cache as the initial category view did, but rather go to the master Rest store, which will fulfill a request for data through an HTTP GET request. This will trigger a request with the same URL structure as our main page, but will include an <code>Accept: application/json</code> header to indicate to the server that a JSON response is expected.</p>\\n<p>In this example, we are only registering a handler for navigating to different filtered views of data to show in our grid. Naturally, an application may have other types of views, perhaps a detailed view of an individual item or product, or an ordering form. We could certainly create alternate handlers for these different views.</p>\\n<p>This router callback function is basically a reactive function, causing the grid to react and sync with collection changes. This conceptually can be used with any type of component or rendering technology that can react to underlying data changes. </p>\\n<p>Also remember that if you are supporting legacy browsers, you will still want to fallback to hash-based navigation for these users.</p>\\n<h3>Triggering Navigation</h3>\\n<p>Finally, we need to actually provide the user interface to trigger navigation. There are numerous options for this. In navigation that is guiding a user to filter grid results, we may want to employ a form with inputs for choosing different search constraints. In this example, we are currently simply filtering on the category, and we could use a simple drop-down to choose a category. With each of these, we could respond to a new filtering requests by calling <code>router.go(queryString)</code> with the new query to send to the server. The router would then handle changing the URL through a <code>pushState</code> call, then handle the change, by updating the current filtered collection used by the grid, which would ultimately result in a new XHR HTTP request to retrieve the new results in JSON form.</p>\\n<p>These types of filtering form controls could all be rendered purely in our client-side code. Here is an example of how we could create a simple HTML dropdown (<code>&lt;select></code>), which would respond to changes by triggering navigation, using <code>put-selector</code> and <code>dojo/on</code>:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\ndefine(['put/selector/put', 'dojo/on'],\\n    function (put, on) {\\n        var categorySelect = put('select', [\\n            put('option[value=food]', 'Food'),\\n            put('option[value=clothing]', 'Clothing'),\\n            put('option[value=auto]', 'Auto Parts'),\\n        ]);\\n        on(categorySelect, 'change', function () {\\n            router.go('?category=' + categorySelect.value);\\n        });\\n    });\\n</pre>\\n<p>As you can see, we respond to the user selecting a category by calling <code>router.go</code> to navigate to the new category to display. Rather than using a native HTML <code>select</code>, we could alternately do this with a Dijit component, like the <code>Select</code> or <code>FilteringSelect</code>.</p>\\n<p>Now we may want to have the list of categories be provided from a server-side database, rather than hard-coding the list in the UI code. On the server-side, it may be convenient to actually dynamically retrieve the list of categories with something like an SQL DISTINCT call (for example <code>SELECT DISTINCT category FROM Product</code>). We could include this in the HTML page, and retrieve the data as an array, or as a pre-populated store as we did early, and use this to render our select element or widget. This leads us to the next improvement we could make to fully integrate the benefits of traditional navigation into a single-page architecture.</p>\\n<h3>Search Engine Visibility</h3>\\n<p>By using the new <code>pushState</code> API in combination with a router, we have successfully provided idiomatic navigation, and by embedding our content in simple HTML form, we have succeeded in making our content easily visible, for quick pre-JavaScript rendering (or even without JavaScript), and for search engine accessibility. However, there is a still missing piece for full search engine indexing. While we have provided users with a means of navigation, we haven&#8217;t made this navigation visible in the HTML. Consequently, search engines can not follow links to additional content that we may have available, and wish to have indexed.</p>\\n<p>Briefly, we can correct this by adding hyperlinks in our HTML representation of our content. The idea of adding links to resources is a central to HTML and a key part of the REST architecture (called Hypermedia as the Engine of Application State or <a href=\\\"https://en.wikipedia.org/wiki/HATEOAS\\\">HATEOAS</a>).</p>\\n<p>We can accomplish this by following the same pattern of microdata usage. We could generate a set of HTML elements that represent our available categories using standard anchor elements. We can make use of server-provided data, and annotate that data with anchor tags:</p>\\n<pre class=\\\"brush: xml; title: ; notranslate\\\" title=\\\"\\\">\\n    &lt;div id=&quot;categories&quot;&gt;\\n        &lt;a itemscope itemid=&quot;food&quot; href=&quot;?category=food&quot;&gt;&lt;span itemprop=&quot;label&quot;&gt;Food&lt;/span&gt;&lt;/a&gt;\\n        &lt;a itemscope itemid=&quot;clothing&quot; href=&quot;?category=clothing&quot;&gt;&lt;span itemprop=&quot;label&quot;&gt;Clothing&lt;/span&gt;&lt;/a&gt;\\n        &lt;a itemscope itemid=&quot;auto&quot; href=&quot;?category=auto&quot;&gt;&lt;span itemprop=&quot;label&quot;&gt;Auto Parts&lt;/span&gt;&lt;/a&gt;\\n    &lt;/div&gt;\\n</pre>\\n<p>We can then read the data from our HTML page using the same function as we read the main page content:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\n    var categories = parseObjects(dom.byId('categories'));\\n</pre>\\n<p>We can then empty this <code>&lt;div></code> and use the generated array to drive our preferred user interface control (a <code>&lt;select></code> drop-down or otherwise).</p>\\n<p>We could also use the same strategy to add hyperlinks to the individual items in the main page content. This could be useful if we are to provide navigation to product details, and we want this navigation to be visible to the search engines for indexing.</p>\\n<h2>Demo</h2>\\n<p>Putting together these examples, we have a demo where you can see the code in action. This is a fairly minimal demonstration, to clearly show the techniques in this post. Again, this is a simple demonstration, and is missing support for older browsers, but this support could easily be added with a fallback to hash-based navigation. Also, this doesn&#8217;t have any server-side coordination. The demo page is assumed to be the response for the <code>food</code> category. Other page navigation is emulated through a mocked JSON HTTP service.</p>\\n<p>Finally, this demo also includes an added one second delay before rendering, to make the rendering progress clearly visible. You should be able to easily see the initial rendering of the content of the page, prior to any JavaScript rendering.</p>\\n<p><a href=\\\"https://user.sitepen.com/~kzyp/packages/navigation-demo/?category=food\\\">Isomorphic resources demo</a>.</p>\\n<h3>Screenshots</h3>\\n<p>Before JavaScript rendering:<br />\\n<a href=\\\"https://user.sitepen.com/~kzyp/packages/navigation-demo/?category=food\\\"><br />\\n<img src=\\\"https://wp.sitepen.com/wp-content/uploads/2015/02/navigation-pre.png\\\" alt=\\\"navigation-pre\\\" width=\\\"522\\\" height=\\\"103\\\" class=\\\"size-full wp-image-10428\\\" /></a></p>\\n<p>After JavaScript rendering:<br />\\n<a href=\\\"https://user.sitepen.com/~kzyp/packages/navigation-demo/?category=food\\\"><br />\\n<img src=\\\"https://wp.sitepen.com/wp-content/uploads/2015/02/navigation-post.png\\\" alt=\\\"navigation-post\\\" width=\\\"525\\\" height=\\\"188\\\" class=\\\"size-full wp-image-10429\\\" /></a></p>\\n<h2>On the Server</h2>\\n<p>The server-side of this type of application could be implemented with virtually any server technology. We have minimized server processing to little more than delivery of content; the main complexity of the user interface is pushed to client-side code. However, we will look briefly at how you could implement this with <a href=\\\"http://persvr.org\\\">Persevere</a>. The Persevere documentation includes examples of how you can easily setup a data model, and expose the data through JSON. And fortunately, Persevere already includes support for handling content negotiation, so that if we register an HTML media handler, it will automatically be selected by the <code>Accept</code> header indication. Our main addition we need to provide is the HTML media handler, that will serialize our data as HTML with the appropriate microdata annotations and included metadata (like navigation options).</p>\\n<h2>Conclusion</h2>\\n<p>This post brings together several different technologies and ideas to define a strategy for creating web applications with modern client-centric architecture, yet still preserving the benefits of traditional pages, in ways that hash-based approaches have never achieved. These new technologies are welcome additions, and fit together elegantly to enable a new class of seamless applications. If you are interested in creating advanced applications that can fully leverage these practices and technologies, we would love to help. <a href=\\\"https://www.sitepen.com/contact/\\\">Contact us</a> for a free 30 minute consultation to discuss your application and how we can assist your organization.</p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>When building web applications, developers often face the dilemma of whether to use traditional server-side rendered pages, or client-centric applications that rely on Ajax/JSON data requests, with client-side rendering of data. These two approaches also tend to dictate navigation (among other things), leading to traditional page navigation or a single-page application (perhaps with hash-based navigation). [&hellip;]</p>\\n\",\"protected\":false},\"author\":28,\"featured_media\":6610,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[45,4,3],\"tags\":[],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.4.1 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Optimized Navigation: Isomorphic Resources | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Optimized Navigation: Isomorphic Resources | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"When building web applications, developers often face the dilemma of whether to use traditional server-side rendered pages, or client-centric applications that rely on Ajax/JSON data requests, with client-side rendering of data. These two approaches also tend to dictate navigation (among other things), leading to traditional page navigation or a single-page application (perhaps with hash-based navigation). [&hellip;]\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2015-02-27T15:14:25+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/\\\",\\\"name\\\":\\\"Optimized Navigation: Isomorphic Resources | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/#primaryimage\\\"},\\\"datePublished\\\":\\\"2015-02-27T15:14:25+00:00\\\",\\\"dateModified\\\":\\\"2015-02-27T15:14:25+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\"},\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/optimized-navigation-isomorphic-resources/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/10421\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=10421\"}],\"version-history\":[{\"count\":0,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/10421/revisions\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/6610\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=10421\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=10421\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=10421\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=10421\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":28,\"name\":\"Kris Zyp\",\"url\":\"https://www.sitepen.com\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/kzyp/\",\"slug\":\"kzyp\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.4.1 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Kris Zyp, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Kris Zyp, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/kzyp/\\\",\\\"name\\\":\\\"Kris Zyp, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/0b6eaf72ddf34f8c761763c239c05087\\\",\\\"name\\\":\\\"Kris Zyp\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/0c073304e94b11bc5a45aa6a3b5fedb7?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Kris Zyp\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/kzyp/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/28\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cf-cache-status","DYNAMIC"],["cf-ray","5a8081318c260706-LHR"],["cf-request-id","03842f12f100000706eb850200000001"],["connection","close"],["content-encoding","gzip"],["content-type","application/json; charset=UTF-8"],["date","Tue, 23 Jun 2020 19:09:39 GMT"],["expect-ct","max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\""],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","cloudflare"],["set-cookie","__cfduid=dbb4b4a67aedae61c56ca2ee8fa0ade561592939379; expires=Thu, 23-Jul-20 19:09:39 GMT; path=/; domain=.sitepen.com; HttpOnly; SameSite=Lax"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}