{"value":{"body":"[{\"id\":333,\"date\":\"2008-05-09T00:02:27\",\"date_gmt\":\"2008-05-09T07:02:27\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/2008/05/09/string-performance-an-analysis/\"},\"modified\":\"2019-12-11T04:51:07\",\"modified_gmt\":\"2019-12-11T12:51:07\",\"slug\":\"string-performance-an-analysis\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/string-performance-an-analysis/\",\"title\":{\"rendered\":\"String Performance: an Analysis\"},\"content\":{\"rendered\":\"<p>Recently I was writing a &#8220;tips and tricks&#8221; blog post that was going to focus on the idea that it is better to use an object as a &#8220;string buffer&#8221;; the idea was that by passing this object around to various functions and pushing string fragments into it, you can get better performance from a JavaScript engine.  My friend and colleague <a href=\\\"http://alex.dojotoolkit.org\\\" title=\\\"Alex Russell\\\">Alex Russell</a> challenged me to show him hard data supporting this hypothesis&mdash;and the results were quite eye-opening!</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/stringperf.png' title='String performance by browser'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/stringperf.png' alt='String performance by browser' width=\\\"700\\\" height=\\\"265\\\" /></a></p>\\n<p><!--more--></p>\\n<p>For this analysis, I used two sources for tests: the dojox.string.Builder <a href=\\\"http://archive.dojotoolkit.org/nightly/dojotoolkit/dojox/string/tests/BuilderPerf.html\\\" title=\\\"Builder performance tests, by Ben Lowery\\\">Builder performance test</a>, and a custom test implementing three versions of a common JavaScript task: a JSON Serializer.  The initial concept was to show that pushing strings into an object buffer would be faster than using the simple JavaScript operations available to any developer.</p>\\n<h2>Background: String Theory.</h2>\\n<p>From my friend and colleague <a href=\\\"http://lazutkin.com/blog/authors/1/\\\" title=\\\"Eugene Lazutkin\\\">Eugene Lazutkin</a> comes this excellent explanation about strings in programming:</p>\\n<blockquote><p>\\nMany modern languages (especially functional languages) employ &#8220;the immutable object&#8221; paradigm, which solves a lot of problems including the memory conservation, the cache localization, addressing concurrency concerns, and so on. The idea is simple: if object is immutable, it can be represented by a reference (a pointer, a handle), and passing a reference is the same as passing an object by value &#8212; if object is immutable, its value cannot be changed => a pointer pointing to this object can be dereferenced producing the same original value. It means we can replicate pointers without replicating objects. And all of them would point to the same object. What do we do when we need to change the object? One popular solution is to use <a href=\\\"http://en.wikipedia.org/wiki/Copy-on-write\\\" title=\\\"Copy-on-write\\\">Copy-on-write (COW)</a>. Under COW principle we have a pointer to the object (a reference, a handle), we clone the object it points to, we change the value of the pointer so now it points to the cloned object, and proceed with our mutating algorithm. All other references are still the same.</p>\\n<p>JavaScript performs all of &#8220;the immutable object&#8221; things for strings, but it doesn&#8217;t do COW on strings because it uses even simpler trick: there is <strong>no way</strong> to modify a string. All strings are immutable by virtue of the language specification and the standard library it comes with. For example: str.replace(&#8220;a&#8221;, &#8220;b&#8221;) doesn&#8217;t modify str at all, it <strong>returns</strong> a new string with the replacement executed. Or not. If the pattern was not found I suspect it&#8217;ll return a pointer to the original string. Every &#8220;mutating&#8221; operation for strings actually returns a new object leaving the original string unchanged: replace, concat, slice, substr, split, and even exotic anchor, big, bold, and so on.\\n</p></blockquote>\\n<p>The issue is usually string operations come with a &#8220;hidden cost&#8221;; because strings are (in theory) immutable, we would expect that any kind of string mutation will come with the costs of copy and replace, taking up valuable CPU cycles, consuming memory space, and putting strains on a garbage collector (among other things).  A typical technique used in many languages is to use something you can pass by reference (like an object or array) to your methods, and push string fragments into that&mdash;delaying the cost of string mutation until it is absolutely needed.  In fact, this was the exact reason I wrote the original <a href=\\\"http://trac.dojotoolkit.org/browser/dojox/trunk/string/Builder.js\\\" title=\\\"dojox.string.Builder\\\">dojox.string.Builder</a>; I borrowed the idea from C# as a way of increasing efficiency for large string operations, such as building a document fragment on the fly or serializing a JavaScript Object Literal.</p>\\n<p>(A side note: the original has gone through quite a few iterations, the latest one by <a href=\\\"http://www.blowery.org/blog/\\\" title=\\\"Ben Lowery\\\">Ben Lowery</a>, who was initially using Builder extensively with <a href=\\\"http://www.bloglines.com\\\" title=\\\"Bloglines\\\">Bloglines</a>.)</p>\\n<p>After doing some fairly extensive testing, I learned that with the modern browsers, this is not the case at all; in fact, not only were typical string operations optimized cross-browser but the performance of dojox.string.Builder was dismal, particularly when compared against native operations.</p>\\n<h2>Round 1: Measuring Native Operations.</h2>\\n<p>The chart at the top of this article is the summary of native operation performance.  All tests were done on a MacBook Pro 2.4Ghz Core 2 Duo, with 4GB of installed RAM; tests were run on both OS X and on Windows 2003 Server running under Parallels Desktop (with enough RAM allocated to ensure consistent results).</p>\\n<p>The first set of tests run was based on the tests made by Ben Lowery (the BuilderPerf test, see link above), using a Lorem Ipsum dictionary with the default numbers (1000 iterations using 100 words).  The basic concept is to test performance based on both one-time and iterative operations.  As an example, here are the tests for <em>concat() once</em> and <em>concat() for</em>:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\n{\\r\\n    name: &quot;concatOnce&quot;,\\r\\n    test: function() {\\r\\n        var s = &quot;&quot;;\\r\\n        s = String.prototype.concat.apply(s, words);\\r\\n        return s;\\r\\n    }\\r\\n},\\r\\n{\\r\\n    name: &quot;concatFor&quot;,\\r\\n    test: function(){\\r\\n        var s = &quot;&quot;;\\r\\n        for(var i=0; i&lt;words.length; i++){\\r\\n            s = s.concat(words[i]);\\r\\n        }\\r\\n        return s;\\r\\n    }\\r\\n}\\r\\n</pre>\\n<p>&#8230;where the variable <em>words</em> is the dictionary initially generated used for all the tests.</p>\\n<p>The results were about what we would expect: one time operations in general executed much faster than iterative ones.  Here&#8217;s the chart again:</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/stringperf.png' title='String performance by browser'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/stringperf.png' alt='String performance by browser' width=\\\"700\\\" height=\\\"265\\\" /></a></p>\\n<p>One interesting result: the <strong>+=</strong> operator on strings is actually <em>faster</em>, across the board, than [string].concat().</p>\\n<p>Taking a closer look, we can also accurately gauge performance by browser.  For example, comparing the major browsers with the <em>once</em> operations:</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/stringonce.png' title='One time operations by browser'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/stringonce.png' alt='One time operations by browser' /></a></p>\\n<p>&#8230;we can see that the two most common browsers, Internet Explorer and Firefox (under Windows) have some issues; <em>join</em> performance with Firefox is not great but <em>concat</em> performance with Internet Explorer is absolutely dismal.</p>\\n<p>However, one time operations such as these&mdash;while attractive and certainly the best performing&mdash;are not nearly as common as operations made during some sort of iteration.  Here&#8217;s the comparison of major browsers using the three most common operations during iteration (join, concat and the &#8220;+=&#8221; operator):</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/stringfor.png' title='String operations through iteration'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/stringfor.png' alt='String operations through iteration' /></a></p>\\n<p>We can draw a few conclusions from this particular chart:</p>\\n<ol>\\n<li>The += operator is faster&mdash;even more than pushing string fragments into an array and joining them at the last minute</li>\\n<li>An array as a string buffer is more efficient on all browsers, with the exception of Firefox 2.0.0.14/Windows, than using String.prototype.concat.apply.</li>\\n</ol>\\n<p>The performance of dojox.string.Builder was also measured with this battery of tests; we&#8217;ll present that data later in the article.</p>\\n<h2>Round 2: Comparing types of buffering techniques.</h2>\\n<p>The second round of tests was performed using three slightly different versions of a typical JSON serializer, based on the <a href=\\\"http://trac.dojotoolkit.org/browser/dojo/trunk/_base/json.js\\\" title=\\\"dojo.toJson\\\">one used in the Dojo Toolkit</a>.  The serializer has three versions:</p>\\n<ol>\\n<li>Recursive serialization using += (passing strings as the result of a function)</li>\\n<li>Recursive serialization using local arrays as buffers (created internally to a function)</li>\\n<li>Serialization using a single array passed to methods as an argument with no return (i.e. void)</li>\\n</ol>\\n<p>The test takes a large pre-loaded Javascript Object Literal structure (the serialized version weighs in at 19,200 characters), and serializes it using all three serializers 10 times, taking the average result.  Each test is run 5 times in succession.  Finally, 20 samples were taken for each browser.</p>\\n<p>The expectation was that a single object as a string buffer would yield better performance results, consistently across browsers.</p>\\n<h3>Results</h3>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonsummary.png' title='Summary of performance through JSON serialization'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonsummary.png' alt='Summary of performance through JSON serialization' /></a></p>\\n<p>In all cases (with the exception of Opera 9.27/Win), using a single object as a string buffer performed the worst, with the best general performance coming from using recursive serialization with the &#8220;+=&#8221; operator.</p>\\n<h4>Comparing Browsers</h4>\\n<p>To shed a little further light&mdash;and to accurately gauge the performance of each browser&mdash;we can compare each serialization technique:</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonconcat.png' title='Serialization using +='><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonconcat.png' alt='Serialization using +=' /></a><br />\\n<a href='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonlocal.png' title='Serialization using local arrays'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonlocal.png' alt='Serialization using local arrays' /></a><br />\\n<a href='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonsingle.png' title='Serialization using an object as buffer'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/jsonsingle.png' alt='Serialization using an object as buffer' /></a></p>\\n<p>As detailed elsewhere, Safari (on both OS X and Windows) is by far the fastest executing browser; unexpectedly, Opera 9.27&mdash;which historically has an excellent track record in terms of performance&mdash;was the least performant in these tests.  Also of interest is the fact that the cross-platform browsers (Safari, Firefox and Opera) remain fairly consistent in terms of actual performance.</p>\\n<h2>Round 3: Applying Results to dojox.string.Builder.</h2>\\n<p>With the results of both rounds available, an analysis of the performance of dojox.string.Builder was undertaken.  Performance numbers (pre-optimization) were captured during the first battery of tests, revealing a number of issues with the Builder.append method (by far the most commonly used method).  However, some investigation and testing resulted in <em>up to a 10x increase in performance</em>&mdash;in some cases, being either comparable to or even beating certain browser operations!</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/buildercomparison.png' title='Before and after optimization of dojox.string.Builder'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/buildercomparison.png' alt='Before and after optimization of dojox.string.Builder' width=\\\"700\\\" height=\\\"170\\\" /></a></p>\\n<p>Because of the very good performance in Safari and Opera, the goal of the optimization process was to address shortcomings in both Internet Explorer and Firefox.</p>\\n<h3>Finding the culprits</h3>\\n<p>Carefully analyzing the original code with dojox.string.Builder.append:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){\\r\\n    return this.appendArray(dojo._toArray(arguments));\\r\\n}\\r\\n</pre>\\n<p>&#8230;we determined that a number of things were causing performance issues:</p>\\n<ul>\\n<li>The call to <em>dojo._toArray</em>, with the <em>arguments</em> object</li>\\n<li>Passing the results to <em>dojox.string.Builder.appendArray</em>, without testing first for a shorter branch</li>\\n<li>Dynamic arguments object access</li>\\n</ul>\\n<h3>Optimization 1: Addressing the Simplest Case.</h3>\\n<p>The first change made introduced a branch, for all browsers, that checks to see if more than one argument was passed.</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){\\r\\n    if(arguments.length&gt;1){\\r\\n        return this.appendArray(dojo._toArray(arguments));\\r\\n    } else {\\r\\n        this.b += s;\\r\\n        return this;\\r\\n    }\\r\\n}\\r\\n</pre>\\n<p>By performing this simple check, we eliminate the need for calling both <em>dojo._toArray</em> as well as the passthrough to the method <em>appendArray</em>.  This change increased the performance of the <em>append</em> method with dramatic results&mdash;referring to the chart above, this was <strong>by far</strong> the greatest performance enhancer.</p>\\n<p>However, when passing multiple arguments to the <em>append</em> method, both Internet Explorer and Firefox slowed down dramatically.</p>\\n<h3>Optimization 2: Fixing Internet Explorer</h3>\\n<p>The internal string buffer used for Internet Explorer is different than any other browser; based on the test results from our first round, we know that pushing string fragments into an array and then <em>join</em>-ing them only when a complete string is needed is the best method for string handling.</p>\\n<p>Knowing that the culprit for real performance issues is the call to <em>dojo._toArray</em> with the arguments object, the goal was to eliminate the need for using it.  One simple way to deal would be to simply iterate through the arguments and append each one, one by one:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){\\r\\n    if(arguments.length&gt;1){\\r\\n        for(var i=0, l=arguments.length; i &lt; l; i++){\\r\\n            this.b.push(arguments[i]);\\r\\n        }\\r\\n    } else {\\r\\n        this.b.push(s);\\r\\n    }\\r\\n    return this;\\r\\n}\\r\\n</pre>\\n<p>This helped a bit, but there was not a dramatic increase in performance.  To eek a bit more out of the method, we tested the difference between using <em>[].push</em> and manually specifying the next available index in the array; we found that specifying the next available index was a bit faster. Finally, we resorted to an implementation of <a href=\\\"http://en.wikipedia.org/wiki/Duff%27s_Device\\\" title=\\\"Duff's Device\\\">Duff&#8217;s Device</a>, a technique for loop unrolling.  Here&#8217;s the final code:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){\\r\\n\\tif(arguments.length&gt;1){\\r\\n\\t\\t//\\tSome Duff's device love here.\\r\\n\\t\\tvar n = Math.floor(arguments.length/8), r = arguments.length%8, i=0;\\r\\n\\t\\tdo {\\r\\n\\t\\t\\tswitch(r){\\r\\n\\t\\t\\t\\tcase 0: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 7: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 6: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 5: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 4: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 3: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 2: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t\\tcase 1: this.b[this.b.length]=arguments[i++];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tr = 0;\\r\\n\\t\\t} while(--n&gt;0);\\r\\n\\t} else {\\r\\n\\t\\tthis.b[this.b.length]=s;\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n</pre>\\n<p>This loop unroll brought the performance of append with multiple arguments down to the same, or faster, than using append with a single argument multiple times.</p>\\n<h3>Optimization 3: Fixing Firefox.</h3>\\n<p>The last set of optimizations involved fixing the dismal performance in Firefox.  Like with Internet Explorer, Firefox had major problems when using <em>dojo._toArray</em>, so the first order of business was to move iterating over the arguments object within the <em>append</em> method itself:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){ \\r\\n\\tif(arguments.length&gt;1){\\r\\n\\t\\tvar i=0;\\r\\n\\t\\twhile(i &lt; arguments.length){\\r\\n\\t\\t\\tthis.b += arguments[i++];\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tthis.b += s;\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n</pre>\\n<p>What this revealed was that accessing members of the <em>arguments</em> object seemed to be <strong>very</strong> slow&mdash;to the point where just iterating over each argument caused enough of a performance hit to actually <em>decrease</em> the performance over using <em>dojo._toArray</em>!</p>\\n<p>With that in mind, and the help of my colleague <a href=\\\"https://www.sitepen.com/blog/author/kzyp/\\\" title=\\\"Kris Zyp\\\">Kris Zyp</a>, what we determined was that the issue in Firefox isn&#8217;t so much that accessing members of the <em>arguments</em> object is the issue; it&#8217;s that <strong>dynamic access</strong> of the <em>arguments</em> object is the problem.  With that in mind, a different kind of loop unroll was called for:</p>\\n<pre class=\\\"brush: jscript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nappend: function(s){ \\r\\n\\tif(arguments.length&gt;1){\\r\\n\\t\\tvar tmp=&quot;&quot;, l=arguments.length;\\r\\n\\t\\tswitch(l){\\r\\n\\t\\t\\tcase 9: tmp=arguments[8]+tmp;\\r\\n\\t\\t\\tcase 8: tmp=arguments[7]+tmp;\\r\\n\\t\\t\\tcase 7: tmp=arguments[6]+tmp;\\r\\n\\t\\t\\tcase 6: tmp=arguments[5]+tmp;\\r\\n\\t\\t\\tcase 5: tmp=arguments[4]+tmp;\\r\\n\\t\\t\\tcase 4: tmp=arguments[3]+tmp;\\r\\n\\t\\t\\tcase 3: tmp=arguments[2]+tmp;\\r\\n\\t\\t\\tcase 2: {\\r\\n\\t\\t\\t\\tthis.b+=arguments[0]+arguments[1]+tmp;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault: {\\r\\n\\t\\t\\t\\tvar i=0;\\r\\n\\t\\t\\t\\twhile(i &lt; arguments.length){\\r\\n\\t\\t\\t\\t\\tthis.b += arguments[i++];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tthis.b += s;\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n</pre>\\n<p>With this unrolling technique, we accomplish the following:</p>\\n<ol>\\n<li>We create a temporary string buffer (<em>tmp</em>)</li>\\n<li>We take advantage of Javascript&#8217;s fall-through <em>switch&#8230;case</em> structure to deal with up to 9 arguments</li>\\n<li>We specify in each <em>case</em> branch the actual argument number</li>\\n<li>We prepend the argument to the temporary buffer</li>\\n<li>&#8230;finally appending the result to the internal buffer (<em>this.b</em>).</li>\\n</ol>\\n<p>This unroll did not noticeably affect the performance of either Safari or Opera, but made a <strong>huge</strong> difference with Firefox; from the chart above, you can see close to a 10x increase in performance with both the Windows and OS X versions of Firefox.  Note that passing more than 9 arguments will cause Firefox to fall back to the dynamic arguments access version; in theory we can simply add more case statements to deal with this, but from a practical standpoint 9 arguments should be a good limit.</p>\\n<h2>Comparing dojox.string.Builder Performance with Native Operations</h2>\\n<p>Finally, we should compare how the new optimized version of dojox.string.Builder compares to the native operations we analyzed in Rounds 1 and 2.  Again, the tests (including a new one that tested the performance of Builder.append with mulitple arguments) were run, as they were with Round 1&mdash;this time with the optimized Builder.</p>\\n<p><a href='https://wp.sitepen.com/wp-content/uploads/2008/05/nativevsbuilder.png' title='Native string ops vs. dojox.string.Builder'><img src='https://wp.sitepen.com/wp-content/uploads/2008/05/nativevsbuilder.png' alt='Native string ops vs. dojox.string.Builder' width=\\\"700\\\" height=\\\"158\\\" /></a></p>\\n<p>With Safari and Opera, dojox.string.Builder is still slightly slower when used in iterative situations; however, the difference is close enough so that one should not find a noticeable decrease in performance when using it.  With Internet Explorer, we find that the performance of the Builder is still pretty bad when compared to native operations.</p>\\n<p>However, with Firefox, the <em>only</em> operation faster than using Builder.append is the &#8220;+=&#8221; operator; both <em>join</em> and <em>concat</em> are close enough to Builder.append that it makes no difference which version you use.</p>\\n<h2>Conclusions</h2>\\n<p>Though this analysis, a number of things about string performance have been observed:</p>\\n<ul>\\n<li>Native string operations in all browsers have been optimized to the point where borrowing techniques from other languages (such as passing around a single buffer for use by many methods) is for the most part unneeded.</li>\\n<li><em>Array.join</em> still seems to be the fastest method with Internet Explorer; either <em>+=</em> or <em>String.prototype.concat.apply(&#8220;&#8221;, arguments)</em> work best for all other browsers.</li>\\n<li>Firefox has definite issues with accessing argument members via dynamic/variables</li>\\n<li>And of course, the reminder to not ignore the data</li>\\n</ul>\\n<p>For those numerically inclined, you can <a href=\\\"https://www.sitepen.com/code/stringPerformance/stringPerformance.pdf\\\" title=\\\"Analysis\\\">download the PDF version of all the data collected.</a></p>\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Recently I was writing a &#8220;tips and tricks&#8221; blog post that was going to focus on the idea that it is better to use an object as a &#8220;string buffer&#8221;; the idea was that by passing this object around to various functions and pushing string fragments into it, you can get better performance from a [&hellip;]</p>\\n\",\"protected\":false},\"author\":15,\"featured_media\":17509,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[46,19,45,3,6],\"tags\":[56],\"series\":[],\"jetpack_featured_media_url\":\"\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.4.1 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>String Performance: an Analysis | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/string-performance-an-analysis/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"String Performance: an Analysis | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"Recently I was writing a &#8220;tips and tricks&#8221; blog post that was going to focus on the idea that it is better to use an object as a &#8220;string buffer&#8221;; the idea was that by passing this object around to various functions and pushing string fragments into it, you can get better performance from a [&hellip;]\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/string-performance-an-analysis/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2008-05-09T07:02:27+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2019-12-11T12:51:07+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2020/01/og_imageV1.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1600\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"900\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/string-performance-an-analysis/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/string-performance-an-analysis/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/string-performance-an-analysis/\\\",\\\"name\\\":\\\"String Performance: an Analysis | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/string-performance-an-analysis/#primaryimage\\\"},\\\"datePublished\\\":\\\"2008-05-09T07:02:27+00:00\\\",\\\"dateModified\\\":\\\"2019-12-11T12:51:07+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/8d656940c34d66b3b8abb8d96024a77d\\\"},\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/string-performance-an-analysis/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/8d656940c34d66b3b8abb8d96024a77d\\\",\\\"name\\\":\\\"Tom Trenka\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Tom Trenka\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/333\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/15\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=333\"}],\"version-history\":[{\"count\":1,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/333/revisions\"}],\"predecessor-version\":[{\"id\":19705,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/333/revisions/19705\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/17509\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=333\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=333\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=333\"},{\"taxonomy\":\"series\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/series?post=333\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":15,\"name\":\"Tom Trenka\",\"url\":\"\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/ttrenka/\",\"slug\":\"ttrenka\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.4.1 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Tom Trenka, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Tom Trenka, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/ttrenka/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/ttrenka/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/ttrenka/\\\",\\\"name\\\":\\\"Tom Trenka, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/8d656940c34d66b3b8abb8d96024a77d\\\",\\\"name\\\":\\\"Tom Trenka\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/6f9453afcd9d67c320df915cd6e9755c?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Tom Trenka\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/ttrenka/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/15\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"code\":\"rest_post_invalid_id\",\"message\":\"Invalid post ID.\",\"data\":{\"status\":404}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cf-cache-status","DYNAMIC"],["cf-ray","5a8088905bd80792-LHR"],["cf-request-id","038433ae3300000792df288200000001"],["connection","close"],["content-encoding","gzip"],["content-type","application/json; charset=UTF-8"],["date","Tue, 23 Jun 2020 19:14:41 GMT"],["expect-ct","max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\""],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","cloudflare"],["set-cookie","__cfduid=dd06931cbc645455d41d75c44331852111592939681; expires=Thu, 23-Jul-20 19:14:41 GMT; path=/; domain=.sitepen.com; HttpOnly; SameSite=Lax"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}