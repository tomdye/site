{"value":{"body":"[{\"id\":15184,\"date\":\"2017-09-19T10:19:10\",\"date_gmt\":\"2017-09-19T17:19:10\",\"guid\":{\"rendered\":\"https://www.sitepen.com/blog/?p=15184\"},\"modified\":\"2020-02-03T06:48:40\",\"modified_gmt\":\"2020-02-03T14:48:40\",\"slug\":\"rethinking-inheritance\",\"status\":\"publish\",\"type\":\"post\",\"link\":\"https://wp.sitepen.com/blog/rethinking-inheritance/\",\"title\":{\"rendered\":\"Rethinking Inheritance\"},\"content\":{\"rendered\":\"<p>Over the past year we&#8217;ve been heads-down working hard on Dojo 2 and its component architecture. The ability to change default component behavior is essential to a widget library, and several tactics exist for doing so. After extensive battle testing of different viable approaches to component modification, we decided to once again equip ES6 inheritance as our primary method of extending component functionality. Here&#8217;s why.</p>\\n<p><!--more--></p>\\n<h2>Changing the Defaults</h2>\\n<p>Since we&#8217;re building a statically-typed reactive component framework, the ability for downstream developers to modify default behavior isn&#8217;t just a nice-to-have, it&#8217;s absolutely essential to Dojo 2&#8217;s usability in real-world applications. In order to understand why inheritance works so well for Dojo 2 components in particular, let&#8217;s first review other approaches that exist for modifying widget behavior:</p>\\n<h3>Using <code>properties</code></h3>\\n<p>The most obvious form of Dojo 2 component customization comes through the use of a widget&#8217;s public API exposed through its <code>properties</code> interface:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nw(TabController, {\\r\\n  alignButtons: Align.right\\r\\n})\\r\\n</pre>\\n<p>Passing different values for specific <code>properties</code>, like passing <code>Align.right</code> for <code>alignButton</code> above, allows for efficient behavioral modification of component instances. For example, if a TabController&#8217;s tabs are normally left-aligned in an application but are right-aligned in one specific use case, passing in a value for <code>alignButtons</code> is an optimal solution for one-off customization.</p>\\n<p>Though using <code>properties</code> works well for instance-based modification, this practice can be both restrictive and tedious in common application scenarios. For example, if a TabController&#8217;s tabs should _always_ be right-aligned throughout an application, <code>alignButtons</code> would need to be explicitly set to <code>Align.right</code> anytime the component is used, which is both brittle and unmaintainable:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nw(TabController, {\\r\\n  alignButtons: Align.right,\\r\\n  tabs: tabsA\\r\\n}),\\r\\nw(TabController, {\\r\\n  alignButtons: Align.right,\\r\\n  tabs: tabsB\\r\\n}),\\r\\nw(TabController, {\\r\\n  alignButtons: Align.right,\\r\\n  tabs: tabsC\\r\\n})\\r\\n</pre>\\n<p>Further, and perhaps more importantly than the verbosity above, modification through <code>properties</code> restricts what can and can&#8217;t be changed for a given component to only the properties exposed by the widget author. This can be especially problematic when creating widgets intended for wide situational reuse. Unless widget authors explicitly account for the specific modification a downstream developer wishes to accomplish, it&#8217;s just not possible using <code>properties</code>.</p>\\n<h3>Using <code>compose</code></h3>\\n<p>As detailed in our <a href=\\\"https://www.sitepen.com/blog/2016/05/19/getting-classy-with-compose/\\\">&#8220;Getting Classy with Compose&#8221;</a> post from over a year ago, <code>compose</code> can provide benefits over ES6 inheritance by embracing a functional approach to class reuse instead of traditional class hierarchies. An advantage to this functional API is its ability to support multiple mixins and thus a form of multiple inheritance. By exposing a limited API that allows for factories to be combined and reused, <code>compose</code> helped safe-guard developers from hard-to-reason inheritance chains because no class hierarchy actually exists in composed factories. For example, the <code>super</code> keyword is intentionally unavailable because newly-composed factories have no reference to the old factories that created it. This type of architecture can help lessen some of the coupling between classes, a common pitfall when dealing with ES6 inheritance.</p>\\n<blockquote><p>\\nWe no longer feel those benefits are strong enough to warrant the effort of leveraging and maintaining a hand-rolled inheritance solution.\\n</p></blockquote>\\n<p>While <code>compose</code> still offers the same benefits today that it did a year ago, we no longer feel those benefits are strong enough to warrant the effort of leveraging and maintaining a hand-rolled inheritance solution. While <code>compose</code> does provide a concept of mixins that can help satisfy certain requirements around multiple inheritance, this approach is still secondary to native support. Because Dojo 2&#8217;s component architecture is highly reactive, several similar secondary approaches to multiple inheritance exist, including TypeScript-enabled decorators and mixing together higher order components. Because <a href=\\\"https://www.sitepen.com/blog/2017/02/22/mixins-and-more-in-typescript-2-2/\\\">new approaches to combining functionality from multiple components</a> have negated the advantages that multiple inheritance once provided, and because we&#8217;ve grown to embrace the simplicity of singular-inheritance, this key benefit of <code>compose</code> is no longer as useful for our needs.</p>\\n<p>We&#8217;ve been able to thoroughly test our original <code>compose</code>-based inheritance approach, and while its API is concise, the static type checking provided by TypeScript mitigates most of the same developer pitfalls <code>compose</code> helped to safeguard against. The fact that TypeScript allows many tight-coupling maintenance issues to be immediately identified and potentially mitigated is a powerful feature of a statically-typed language, and a key reason why <code>compose</code> is no longer the best tool for Dojo 2.</p>\\n<h3>Using higher order components</h3>\\n<p>A common solution to sharing code between components and also to solving the verbosity and maintainability issues above is through the use of higher order components. Using this pattern, a function is called that returns a new component that wraps an underlying component that can have conditional behavior or rendering based on function arguments. For example, continuing with the TabController example above, if a TabController&#8217;s tabs should always be right-aligned throughout an application, a higher order component could be used to abstract away the <code>alignButtons</code> property:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nv('div', { key: 'some-tabs' }, [\\r\\n  w(createTabs(tabsA))\\r\\n]),\\r\\nv('div', { key: 'some-more-tabs' }, [\\r\\n  w(createTabs(tabsB))\\r\\n]),\\r\\nv('div', { key: 'some-other-tabs' }, [\\r\\n  w(createTabs(tabsC))\\r\\n])\\r\\n</pre>\\n<p>The only parameter for this example function is <code>tabs</code> so that different tab arrays can be passed into each wrapped TabController, but any number of parameters could be used:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction createTabs(tabs) {\\r\\n  return class extends WidgetBase {\\r\\n    protected render(): DNode {\\r\\n      return w(TabController, {\\r\\n        alignButtons: Align.right,\\r\\n        tabs\\r\\n      });\\r\\n    }\\r\\n  };\\r\\n}\\r\\n</pre>\\n<p>This pattern has several advantages. It allows for the modification of components through properties without the lack of maintainability caused by explicitly passing in the same property values every time a component is used, as seen above. This pattern also effectively allows for shared logic between components by returning a wrapped component that can contain common code; the generating function can accept a component class as a parameter for greater internal rendering decoupling:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nfunction createAutoSaveComponent(Component) {\\r\\n  return class extends WidgetBase {\\r\\n    save() {\\r\\n      // common save logic\\r\\n    }\\r\\n\\r\\n    protected render(): DNode {\\r\\n      return w(Component, {\\r\\n        onClose: save\\r\\n      });\\r\\n    }\\r\\n  };\\r\\n}\\r\\n</pre>\\n<p>Despite the flexibility and maintainability advantages that higher order components can provide, they still inherently rely on <code>properties</code> to customize the underlying component that&#8217;s wrapped. Again, this could be a limitation when authoring reusable components: because inheritance isn&#8217;t used to copy behavior from the underlying component, the same property-based restrictions as to what downstream developers can and can&#8217;t modify still apply even within higher order components.</p>\\n<h2>So, ES6 Inheritance?</h2>\\n<p>ES6 class-based inheritance provides another mechanism to customize the behavior and UI of a component in a reusable manner. Because Dojo 2 components are already authored using inheritance by way of <code>WidgetBase</code> and other base classes, the pattern of extending a component class and overriding members is a familiar one for downstream developers. Say an application had a requirement to use native HTML radio inputs instead of default Dojo 2 TabButtons to control tabs:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass MyTabController extends TabController {\\r\\n  renderTabButtons() {\\r\\n    return this._tabs.map((tab, i) =&gt; {\\r\\n      return w('Radio', {\\r\\n        // ...\\r\\n      })\\r\\n    };\\r\\n  }\\r\\n}\\r\\n</pre>\\n<p><code>renderTabButtons</code> could be overridden to provide a modified <code>DNode[]</code> and static type checking enforces that the overridden method signature matches.</p>\\n<h3>TypeScript === Maintainability</h3>\\n<p>Popular functional frameworks like React have warned against using inheritance in certain situations for key reasons. Extending many classes can introduce layers of chained complexity that can make it difficult to determine where existing functionality lives or new functionality should be added. This point isn&#8217;t specific to functional programming and is heavily backed up by Dojo 1&#8217;s architecture of circular mixins and base classes. Second, React warns that inheritance introduces implicit, tightly-coupled code dependencies, such as a base class calling a method in the parent class or vice versa. React implies that this tight coupling between base and parent class is brittle and leads to unexpected naming errors when changing member names, which isn&#8217;t maintainable.</p>\\n<p>In the context of Dojo 2 widgets written in TypeScript, the maintainability argument isn&#8217;t applicable; IntelliSense and <code>tsc</code> will indicate that name clashes or errors exist when downstream developers change component code that extends our default components. This is a powerful advantage of using static type checking. TypeScript goes further and allows our components to strictly adhere to method visibility patterns, only exposing methods intended to be overridden using the <code>protected</code> keyword, giving downstream developers clear, self-documented extension points.</p>\\n<p>The type of modification provided by inheritance, even inheritance controlled by member visibility keywords, does come with special considerations. In Dojo 2, it&#8217;s almost never correct to extend the <code>render</code> method of a pre-fabricated component. As such, most of a component&#8217;s <code>render</code> method should off-load element generation to helper methods:</p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nprotected renderResult(result: any): DNode {\\r\\n  const { getResultLabel } = this.properties;\\r\\n  return v('div', [ getResultLabel(result) ]);\\r\\n}\\r\\n\\r\\nrender(): DNode {\\r\\n  const {\\r\\n    isDisabled,\\r\\n    result,\\r\\n    selected\\r\\n  } = this.properties;\\r\\n\\r\\n  return v('div', {\\r\\n    'aria-selected': selected ? 'true' : 'false',\\r\\n    'aria-disabled': isDisabled(result) ? 'true' : 'false',\\r\\n    classes: this.classes(\\r\\n      css.option,\\r\\n      selected ? css.selected : null,\\r\\n      isDisabled(result) ? css.disabledOption : null\\r\\n    ),\\r\\n    'data-selected': selected ? 'true' : 'false',\\r\\n    onmousedown: this._onMouseDown,\\r\\n    onmouseenter: this._onMouseEnter,\\r\\n    onmouseup: this._onMouseUp,\\r\\n    role: 'option'\\r\\n  }, [\\r\\n    this.renderResult(result)\\r\\n  ]);\\r\\n}\\r\\n</pre>\\n<p>This example code is from the ResultItem for the Dojo 2 ComboBox; <code>renderResult</code> would be extended, shielding downstream developers from having to reimplement the mostly-internal-specific <code>render</code> method. This pattern of off-loading element generation logic to helper methods allows for safer component extension using simpler method signatures.</p>\\n<h3>Bonus: Working with the Registry</h3>\\n<p>The Dojo 2 widget system provides the concept of a <code>registry</code> that can be used to swap out classes used internally by a component. For example, if the TabController made use of an internal registry, it may accept a <code>customTabButton</code> property that could be any class that implements the TabButton interface. A registry is a powerful tool for providing entire components to another component for internal use, a form of component modification that allows entire portions of a component to be modified at once. Because most uses of the registry involve providing a component class that extends some default component class, inheritance again feels natural: </p>\\n<pre class=\\\"brush: typescript; title: ; notranslate\\\" title=\\\"\\\">\\r\\nclass CustomTabButton extends TabButton {\\r\\n  renderButton(result: any) {\\r\\n    return w('Radio', {\\r\\n      // ...\\r\\n    });\\r\\n  }\\r\\n}\\r\\n\\r\\nw(TabController, {\\r\\n  customTabButton: CustomTabButton,\\r\\n  // ...\\r\\n}),\\r\\n</pre>\\n<h2>Conclusion</h2>\\n<p>Component modification is a central feature to any successful widget framework designed for enterprise use. While a hand-rolled solution like <code>compose</code> does provide many benefits, its usefulness is lessened in the context of a the Dojo 2 widget system that&#8217;s statically typed. By using strict TypeScript member visibility and method signatures, a high degree of security can be added to traditional ES6 inheritance to gain the benefits and discipline of <code>compose</code>-style development, while using a native approach that works well with Dojo 2-specific features like the component registry. Inheritance is the most effective and natural form of customization in Dojo 2, and one that embraces the language features provided by ES6+ and TypeScript.</p>\\n<hr />\\n<h2>Learning more</h2>\\n<div>\\n<p><a href=\\\"https://dojo.io\\\"><img class=\\\"alignleft\\\" style=\\\"margin-top: 0px;\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2016/11/sourcelogoblogs2.png\\\" alt=\\\"Source Code Logo\\\" width=\\\"28\\\" /></a></p>\\n<p style=\\\"margin-top: -5px;\\\">Visit the <a href=\\\"https://dojo.io\\\">dojo.io</a> to see how the code works and for the most up-to-date information about all things Dojo.</p>\\n<p><a href=\\\"https://www.sitepen.com/services/\\\"><img class=\\\"alignleft\\\" style=\\\"margin-top: 0px;\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2016/06/SupportLogoBlogs2.jpg\\\" alt=\\\"Support Logo\\\" width=\\\"28\\\" /></a></p>\\n<p style=\\\"margin-top: -5px;\\\">Get help from <a href=\\\"https://www.sitepen.com/services/\\\">SitePen On-Demand Development</a>, our fast and efficient solutions to JavaScript development problems of any size.</p>\\n<p><a href=\\\"https://www.sitepen.com/contact/\\\"><img class=\\\"alignleft\\\" style=\\\"margin-top: 0;\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2016/06/ConsultingLogoBlogs2.jpg\\\" alt=\\\"Let's Talk! Logo\\\" width=\\\"30\\\" /></a></p>\\n<p style=\\\"margin-top: -5px;\\\"><a href=\\\"https://www.sitepen.com/contact/\\\">Let&#8217;s talk</a> about how we can help your organization improve their approach to automated testing.</p>\\n<p><a href=\\\"https://www.sitepen.com/contact/\\\"><img class=\\\"alignleft\\\" style=\\\"margin-top: 0;\\\" src=\\\"https://wp.sitepen.com/wp-content/uploads/2016/06/ContactLogoBlogs2.jpg\\\" alt=\\\"Contact Us Logo\\\" width=\\\"30\\\" /></a></p>\\n<p style=\\\"margin-top: -5px;\\\">Have a question? We&#8217;re here to help! <a href=\\\"https://www.sitepen.com/contact/\\\">Get in touch</a> and let&#8217;s see how we can work together.</p>\\n</div>\\n<p style=\\\"padding-bottom: 5px;\\\">\\n\",\"protected\":false},\"excerpt\":{\"rendered\":\"<p>Over the past year we&#8217;ve been heads-down working hard on Dojo 2 and its component architecture. The ability to change default component behavior is essential to a widget library, and several tactics exist for doing so. After extensive battle testing of different viable approaches to component modification, we decided to once again equip ES6 inheritance [&hellip;]</p>\\n\",\"protected\":false},\"author\":46,\"featured_media\":22186,\"comment_status\":\"closed\",\"ping_status\":\"closed\",\"sticky\":false,\"template\":\"\",\"format\":\"standard\",\"meta\":{\"spay_email\":\"\"},\"categories\":[214,2,215,11],\"tags\":[5],\"jetpack_featured_media_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\",\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.3 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Rethinking Inheritance | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"index, follow\\\" />\\n<meta name=\\\"googlebot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<meta name=\\\"bingbot\\\" content=\\\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\\\" />\\n<link rel=\\\"canonical\\\" href=\\\"https://www.sitepen.com/blog/rethinking-inheritance/\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Rethinking Inheritance | SitePen\\\" />\\n<meta property=\\\"og:description\\\" content=\\\"Over the past year we&#8217;ve been heads-down working hard on Dojo 2 and its component architecture. The ability to change default component behavior is essential to a widget library, and several tactics exist for doing so. After extensive battle testing of different viable approaches to component modification, we decided to once again equip ES6 inheritance [&hellip;]\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/rethinking-inheritance/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:published_time\\\" content=\\\"2017-09-19T17:19:10+00:00\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-02-03T14:48:40+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1200\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"630\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/rethinking-inheritance/#primaryimage\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\",\\\"width\\\":1200,\\\"height\\\":630,\\\"caption\\\":\\\"Rethinking Inheritance\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/rethinking-inheritance/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/rethinking-inheritance/\\\",\\\"name\\\":\\\"Rethinking Inheritance | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"primaryImageOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/rethinking-inheritance/#primaryimage\\\"},\\\"datePublished\\\":\\\"2017-09-19T17:19:10+00:00\\\",\\\"dateModified\\\":\\\"2020-02-03T14:48:40+00:00\\\",\\\"author\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/7a3e92a258cea881b49680a18b593d71\\\"},\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://www.sitepen.com/blog/rethinking-inheritance/\\\"]}]},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/7a3e92a258cea881b49680a18b593d71\\\",\\\"name\\\":\\\"Paul Bouchon\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Paul Bouchon\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/15184\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/post\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/46\"}],\"replies\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/comments?post=15184\"}],\"version-history\":[{\"count\":1,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/15184/revisions\"}],\"predecessor-version\":[{\"id\":22187,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/posts/15184/revisions/22187\"}],\"wp:featuredmedia\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/22186\"}],\"wp:attachment\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media?parent=15184\"}],\"wp:term\":[{\"taxonomy\":\"category\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/categories?post=15184\"},{\"taxonomy\":\"post_tag\",\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/tags?post=15184\"}],\"curies\":[{\"name\":\"wp\",\"href\":\"https://api.w.org/{rel}\",\"templated\":true}]},\"_embedded\":{\"author\":[{\"id\":46,\"name\":\"Paul Bouchon\",\"url\":\"\",\"description\":\"\",\"link\":\"https://wp.sitepen.com/blog/author/pbouchon/\",\"slug\":\"pbouchon\",\"avatar_urls\":{\"24\":\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=24&d=mm&r=g\",\"48\":\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=48&d=mm&r=g\",\"96\":\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=96&d=mm&r=g\"},\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.3 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Paul Bouchon, Author at SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"profile\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Paul Bouchon, Author at SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://www.sitepen.com/blog/author/pbouchon/\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=500&#038;d=mm&#038;r=g\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"ProfilePage\\\",\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/pbouchon/#webpage\\\",\\\"url\\\":\\\"https://www.sitepen.com/blog/author/pbouchon/\\\",\\\"name\\\":\\\"Paul Bouchon, Author at SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":[\\\"Person\\\"],\\\"@id\\\":\\\"https://wp.sitepen.com/#/schema/person/7a3e92a258cea881b49680a18b593d71\\\",\\\"name\\\":\\\"Paul Bouchon\\\",\\\"image\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#personlogo\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"url\\\":\\\"https://secure.gravatar.com/avatar/89cb35910e3b9fed1219d3669a454387?s=96&d=mm&r=g\\\",\\\"caption\\\":\\\"Paul Bouchon\\\"},\\\"mainEntityOfPage\\\":{\\\"@id\\\":\\\"https://www.sitepen.com/blog/author/pbouchon/#webpage\\\"}}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/46\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users\"}]}}],\"wp:featuredmedia\":[{\"id\":22186,\"date\":\"2020-02-03T06:48:26\",\"slug\":\"rethinking-inheritance-2\",\"type\":\"attachment\",\"link\":\"https://wp.sitepen.com/blog/rethinking-inheritance/rethinking-inheritance-2/\",\"title\":{\"rendered\":\"Rethinking Inheritance\"},\"author\":5,\"yoast_head\":\"<!-- This site is optimized with the Yoast SEO plugin v14.3 - https://yoast.com/wordpress/plugins/seo/ -->\\n<title>Rethinking Inheritance | SitePen</title>\\n<meta name=\\\"robots\\\" content=\\\"noindex, follow\\\" />\\n<meta property=\\\"og:locale\\\" content=\\\"en_US\\\" />\\n<meta property=\\\"og:type\\\" content=\\\"article\\\" />\\n<meta property=\\\"og:title\\\" content=\\\"Rethinking Inheritance | SitePen\\\" />\\n<meta property=\\\"og:url\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\" />\\n<meta property=\\\"og:site_name\\\" content=\\\"SitePen\\\" />\\n<meta property=\\\"article:publisher\\\" content=\\\"https://www.facebook.com/SitePen\\\" />\\n<meta property=\\\"article:modified_time\\\" content=\\\"2020-02-03T14:48:31+00:00\\\" />\\n<meta property=\\\"og:image\\\" content=\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\" />\\n\\t<meta property=\\\"og:image:width\\\" content=\\\"1200\\\" />\\n\\t<meta property=\\\"og:image:height\\\" content=\\\"630\\\" />\\n<meta name=\\\"twitter:card\\\" content=\\\"summary_large_image\\\" />\\n<meta name=\\\"twitter:creator\\\" content=\\\"@SitePen\\\" />\\n<meta name=\\\"twitter:site\\\" content=\\\"@SitePen\\\" />\\n<script type=\\\"application/ld+json\\\" class=\\\"yoast-schema-graph\\\">{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@graph\\\":[{\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\",\\\"url\\\":\\\"https://wp.sitepen.com/\\\",\\\"name\\\":\\\"SitePen\\\",\\\"description\\\":\\\"Enterprise Web Apps Done Right\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":\\\"https://wp.sitepen.com/?s={search_term_string}\\\",\\\"query-input\\\":\\\"required name=search_term_string\\\"}],\\\"inLanguage\\\":\\\"en-US\\\"},{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg#webpage\\\",\\\"url\\\":\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\",\\\"name\\\":\\\"Rethinking Inheritance | SitePen\\\",\\\"isPartOf\\\":{\\\"@id\\\":\\\"https://wp.sitepen.com/#website\\\"},\\\"datePublished\\\":\\\"2020-02-03T14:48:26+00:00\\\",\\\"dateModified\\\":\\\"2020-02-03T14:48:31+00:00\\\",\\\"inLanguage\\\":\\\"en-US\\\",\\\"potentialAction\\\":[{\\\"@type\\\":\\\"ReadAction\\\",\\\"target\\\":[\\\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\\\"]}]}]}</script>\\n<!-- / Yoast SEO plugin. -->\",\"caption\":{\"rendered\":\"\"},\"alt_text\":\"Rethinking Inheritance\",\"media_type\":\"image\",\"mime_type\":\"image/jpeg\",\"media_details\":{\"width\":1200,\"height\":630,\"file\":\"2017/09/Rethinking-Inheritance.jpg\",\"sizes\":{\"medium\":{\"file\":\"Rethinking-Inheritance-300x158.jpg\",\"width\":300,\"height\":158,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance-300x158.jpg\"},\"large\":{\"file\":\"Rethinking-Inheritance-1024x538.jpg\",\"width\":1024,\"height\":538,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance-1024x538.jpg\"},\"thumbnail\":{\"file\":\"Rethinking-Inheritance-150x150.jpg\",\"width\":150,\"height\":150,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance-150x150.jpg\"},\"medium_large\":{\"file\":\"Rethinking-Inheritance-768x403.jpg\",\"width\":768,\"height\":403,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance-768x403.jpg\"},\"full\":{\"file\":\"Rethinking-Inheritance.jpg\",\"width\":1200,\"height\":630,\"mime_type\":\"image/jpeg\",\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\"}},\"image_meta\":{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\",\"keywords\":[]}},\"source_url\":\"https://wp.sitepen.com/wp-content/uploads/2017/09/Rethinking-Inheritance.jpg\",\"_links\":{\"self\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media/22186\"}],\"collection\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/media\"}],\"about\":[{\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/types/attachment\"}],\"author\":[{\"embeddable\":true,\"href\":\"https://wp.sitepen.com/wp-json/wp/v2/users/5\"}]}}]}}]","headers":[["access-control-allow-headers","Authorization, Content-Type"],["access-control-expose-headers","X-WP-Total, X-WP-TotalPages"],["allow","GET"],["cf-cache-status","DYNAMIC"],["cf-ray","5a774a016d1b0796-LHR"],["cf-request-id","037e6c94df0000079621395200000001"],["connection","close"],["content-encoding","gzip"],["content-type","application/json; charset=UTF-8"],["date","Mon, 22 Jun 2020 16:19:07 GMT"],["expect-ct","max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\""],["link","<https://wp.sitepen.com/wp-json/>; rel=\"https://api.w.org/\""],["server","cloudflare"],["set-cookie","__cfduid=d94786ed1c062315299f402fe4b14df2a1592842747; expires=Wed, 22-Jul-20 16:19:07 GMT; path=/; domain=.sitepen.com; HttpOnly; SameSite=Lax"],["transfer-encoding","chunked"],["vary","Origin"],["x-content-type-options","nosniff"],["x-robots-tag","noindex"],["x-wp-total","1"],["x-wp-totalpages","1"]]},"type":"Object"}